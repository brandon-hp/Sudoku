<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">
	<head>
        <meta charset="utf-8"/>
	    <title>type_traits</title>
	    <link href="../../third-party/google-code-prettify/prettify-CppCoverage.css" type="text/css" rel="stylesheet" />
	    <script type="text/javascript" src="../../third-party/google-code-prettify/prettify.js"></script>
	</head>
	<body onload="prettyPrint()">
        <h4></h4>
		<pre class="prettyprint lang-cpp linenums">
// type_traits standard header (core)

// Copyright (c) Microsoft Corporation.
// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception

#pragma once
#ifndef _TYPE_TRAITS_
#define _TYPE_TRAITS_
#include &lt;yvals_core.h&gt;
#if _STL_COMPILER_PREPROCESSOR
#include &lt;xstddef&gt;

#pragma pack(push, _CRT_PACKING)
#pragma warning(push, _STL_WARNING_LEVEL)
#pragma warning(disable : _STL_DISABLED_WARNINGS)
_STL_DISABLE_CLANG_WARNINGS
#pragma push_macro("new")
#undef new

_STD_BEGIN
// STRUCT TEMPLATE integer_sequence
template &lt;class _Ty, _Ty... _Vals&gt;
struct integer_sequence { // sequence of integer parameters
    static_assert(is_integral_v&lt;_Ty&gt;, "integer_sequence&lt;T, I...&gt; requires T to be an integral type.");

    using value_type = _Ty;

    _NODISCARD static constexpr size_t size() noexcept {
        return sizeof...(_Vals);
    }
};

// ALIAS TEMPLATE make_integer_sequence
template &lt;class _Ty, _Ty _Size&gt;
using make_integer_sequence = __make_integer_seq&lt;integer_sequence, _Ty, _Size&gt;;

template &lt;size_t... _Vals&gt;
using index_sequence = integer_sequence&lt;size_t, _Vals...&gt;;

template &lt;size_t _Size&gt;
using make_index_sequence = make_integer_sequence&lt;size_t, _Size&gt;;

template &lt;class... _Types&gt;
using index_sequence_for = make_index_sequence&lt;sizeof...(_Types)&gt;;

// STRUCT TEMPLATE conjunction
template &lt;bool _First_value, class _First, class... _Rest&gt;
struct _Conjunction { // handle false trait or last trait
    using type = _First;
};

template &lt;class _True, class _Next, class... _Rest&gt;
struct _Conjunction&lt;true, _True, _Next, _Rest...&gt; { // the first trait is true, try the next one
    using type = typename _Conjunction&lt;_Next::value, _Next, _Rest...&gt;::type;
};

template &lt;class... _Traits&gt;
struct conjunction : true_type {}; // If _Traits is empty, true_type

template &lt;class _First, class... _Rest&gt;
struct conjunction&lt;_First, _Rest...&gt; : _Conjunction&lt;_First::value, _First, _Rest...&gt;::type {
    // the first false trait in _Traits, or the last trait if none are false
};

template &lt;class... _Traits&gt;
_INLINE_VAR constexpr bool conjunction_v = conjunction&lt;_Traits...&gt;::value;

// STRUCT TEMPLATE negation
template &lt;class _Trait&gt;
struct negation : bool_constant&lt;!static_cast&lt;bool&gt;(_Trait::value)&gt; {}; // The negated result of _Trait

template &lt;class _Trait&gt;
_INLINE_VAR constexpr bool negation_v = negation&lt;_Trait&gt;::value;

#if _HAS_CXX20
// ENUM CLASS endian
enum class endian { little = 0, big = 1, native = little };
#endif // _HAS_CXX20

// STRUCT TEMPLATE _Arg_types
template &lt;class... _Types&gt;
struct _Arg_types {}; // provide argument_type, etc. (sometimes)

template &lt;class _Ty1&gt;
struct _Arg_types&lt;_Ty1&gt; {
    _CXX17_DEPRECATE_ADAPTOR_TYPEDEFS typedef _Ty1 argument_type;
};

template &lt;class _Ty1, class _Ty2&gt;
struct _Arg_types&lt;_Ty1, _Ty2&gt; {
    _CXX17_DEPRECATE_ADAPTOR_TYPEDEFS typedef _Ty1 first_argument_type;
    _CXX17_DEPRECATE_ADAPTOR_TYPEDEFS typedef _Ty2 second_argument_type;
};

// STRUCT TEMPLATE is_function
template &lt;class _Ty&gt;
struct _Is_function { // determine whether _Ty is a function
    using _Bool_type = false_type; // NB: members are user-visible via _Weak_types
};

#define _IS_FUNCTION(CALL_OPT, CV_OPT, REF_OPT, NOEXCEPT_OPT)                                           \
    template &lt;class _Ret, class... _Types&gt;                                                              \
    struct _Is_function&lt;_Ret CALL_OPT(_Types...) CV_OPT REF_OPT NOEXCEPT_OPT&gt; : _Arg_types&lt;_Types...&gt; { \
        using _Bool_type = true_type;                                                                   \
        _CXX17_DEPRECATE_ADAPTOR_TYPEDEFS typedef _Ret result_type;                                     \
    };

_NON_MEMBER_CALL_CV_REF_NOEXCEPT(_IS_FUNCTION)
#undef _IS_FUNCTION

#define _IS_FUNCTION_ELLIPSIS(CV_REF_NOEXCEPT_OPT)                                                            \
    template &lt;class _Ret, class... _Types&gt;                                                                    \
    struct _Is_function&lt;_Ret(_Types..., ...) CV_REF_NOEXCEPT_OPT&gt; { /* no calling conventions for ellipsis */ \
        using _Bool_type = true_type;                                                                         \
        _CXX17_DEPRECATE_ADAPTOR_TYPEDEFS typedef _Ret result_type;                                           \
    };

_CLASS_DEFINE_CV_REF_NOEXCEPT(_IS_FUNCTION_ELLIPSIS)
#undef _IS_FUNCTION_ELLIPSIS

template &lt;class _Ty&gt;
struct is_function : _Is_function&lt;_Ty&gt;::_Bool_type {}; // determine whether _Ty is a function

template &lt;class _Ty&gt;
_INLINE_VAR constexpr bool is_function_v = _Is_function&lt;_Ty&gt;::_Bool_type::value;


template &lt;class _Ty&gt;
struct _Is_memfunptr { // base class for member function pointer predicates
    using _Bool_type = false_type; // NB: members are user-visible via _Weak_types
};

#define _IS_MEMFUNPTR(CALL_OPT, CV_OPT, REF_OPT, NOEXCEPT_OPT)                            \
    template &lt;class _Ret, class _Arg0, class... _Types&gt;                                   \
    struct _Is_memfunptr&lt;_Ret (CALL_OPT _Arg0::*)(_Types...) CV_OPT REF_OPT NOEXCEPT_OPT&gt; \
        : _Arg_types&lt;CV_OPT _Arg0*, _Types...&gt; {                                          \
        using _Bool_type = true_type;                                                     \
        _CXX17_DEPRECATE_ADAPTOR_TYPEDEFS typedef _Ret result_type;                       \
        using _Class_type = _Arg0;                                                        \
        using _Guide_type = enable_if&lt;!is_same_v&lt;int REF_OPT, int&amp;&amp;&gt;, _Ret(_Types...)&gt;;   \
    };

_MEMBER_CALL_CV_REF_NOEXCEPT(_IS_MEMFUNPTR)
#undef _IS_MEMFUNPTR

#define _IS_MEMFUNPTR_ELLIPSIS(CV_REF_NOEXCEPT_OPT)                          \
    template &lt;class _Ret, class _Arg0, class... _Types&gt;                      \
    struct _Is_memfunptr&lt;_Ret (_Arg0::*)(_Types..., ...)                     \
            CV_REF_NOEXCEPT_OPT&gt; { /* no calling conventions for ellipsis */ \
        using _Bool_type = true_type;                                        \
        _CXX17_DEPRECATE_ADAPTOR_TYPEDEFS typedef _Ret result_type;          \
        using _Class_type = _Arg0;                                           \
        using _Guide_type = enable_if&lt;false&gt;;                                \
    };

_CLASS_DEFINE_CV_REF_NOEXCEPT(_IS_MEMFUNPTR_ELLIPSIS)
#undef _IS_MEMFUNPTR_ELLIPSIS

// STRUCT TEMPLATE is_void
template &lt;class _Ty&gt;
_INLINE_VAR constexpr bool is_void_v = is_same_v&lt;remove_cv_t&lt;_Ty&gt;, void&gt;;

template &lt;class _Ty&gt;
struct is_void : bool_constant&lt;is_void_v&lt;_Ty&gt;&gt; {};

// ALIAS TEMPLATE void_t
template &lt;class... _Types&gt;
using void_t = void;

// Type modifiers
// STRUCT TEMPLATE add_const
template &lt;class _Ty&gt;
struct add_const { // add top-level const qualifier
    using type = const _Ty;
};

template &lt;class _Ty&gt;
using add_const_t = typename add_const&lt;_Ty&gt;::type;

// STRUCT TEMPLATE add_volatile
template &lt;class _Ty&gt;
struct add_volatile { // add top-level volatile qualifier
    using type = volatile _Ty;
};

template &lt;class _Ty&gt;
using add_volatile_t = typename add_volatile&lt;_Ty&gt;::type;

// STRUCT TEMPLATE add_cv
template &lt;class _Ty&gt;
struct add_cv { // add top-level const and volatile qualifiers
    using type = const volatile _Ty;
};

template &lt;class _Ty&gt;
using add_cv_t = typename add_cv&lt;_Ty&gt;::type;

// STRUCT TEMPLATE _Add_reference
template &lt;class _Ty, class = void&gt;
struct _Add_reference { // add reference (non-referenceable type)
    using _Lvalue = _Ty;
    using _Rvalue = _Ty;
};

template &lt;class _Ty&gt;
struct _Add_reference&lt;_Ty, void_t&lt;_Ty&amp;&gt;&gt; { // (referenceable type)
    using _Lvalue = _Ty&amp;;
    using _Rvalue = _Ty&amp;&amp;;
};

// STRUCT TEMPLATE add_lvalue_reference
template &lt;class _Ty&gt;
struct add_lvalue_reference {
    using type = typename _Add_reference&lt;_Ty&gt;::_Lvalue;
};

template &lt;class _Ty&gt;
using add_lvalue_reference_t = typename _Add_reference&lt;_Ty&gt;::_Lvalue;

// STRUCT TEMPLATE add_rvalue_reference
template &lt;class _Ty&gt;
struct add_rvalue_reference {
    using type = typename _Add_reference&lt;_Ty&gt;::_Rvalue;
};

template &lt;class _Ty&gt;
using add_rvalue_reference_t = typename _Add_reference&lt;_Ty&gt;::_Rvalue;

// FUNCTION TEMPLATE declval
template &lt;class _Ty&gt;
add_rvalue_reference_t&lt;_Ty&gt; declval() noexcept;

// STRUCT TEMPLATE remove_extent
template &lt;class _Ty&gt;
struct remove_extent { // remove array extent
    using type = _Ty;
};

template &lt;class _Ty, size_t _Ix&gt;
struct remove_extent&lt;_Ty[_Ix]&gt; {
    using type = _Ty;
};

template &lt;class _Ty&gt;
struct remove_extent&lt;_Ty[]&gt; {
    using type = _Ty;
};

template &lt;class _Ty&gt;
using remove_extent_t = typename remove_extent&lt;_Ty&gt;::type;

// STRUCT TEMPLATE remove_all_extents
template &lt;class _Ty&gt;
struct remove_all_extents { // remove all array extents
    using type = _Ty;
};

template &lt;class _Ty, size_t _Ix&gt;
struct remove_all_extents&lt;_Ty[_Ix]&gt; {
    using type = typename remove_all_extents&lt;_Ty&gt;::type;
};

template &lt;class _Ty&gt;
struct remove_all_extents&lt;_Ty[]&gt; {
    using type = typename remove_all_extents&lt;_Ty&gt;::type;
};

template &lt;class _Ty&gt;
using remove_all_extents_t = typename remove_all_extents&lt;_Ty&gt;::type;

// STRUCT TEMPLATE remove_pointer
template &lt;class _Ty&gt;
struct remove_pointer {
    using type = _Ty;
};

template &lt;class _Ty&gt;
struct remove_pointer&lt;_Ty*&gt; {
    using type = _Ty;
};

template &lt;class _Ty&gt;
struct remove_pointer&lt;_Ty* const&gt; {
    using type = _Ty;
};

template &lt;class _Ty&gt;
struct remove_pointer&lt;_Ty* volatile&gt; {
    using type = _Ty;
};


template &lt;class _Ty&gt;
struct remove_pointer&lt;_Ty* const volatile&gt; {
    using type = _Ty;
};

template &lt;class _Ty&gt;
using remove_pointer_t = typename remove_pointer&lt;_Ty&gt;::type;

// STRUCT TEMPLATE add_pointer
template &lt;class _Ty, class = void&gt;
struct _Add_pointer { // add pointer (pointer type cannot be formed)
    using type = _Ty;
};

template &lt;class _Ty&gt;
struct _Add_pointer&lt;_Ty, void_t&lt;remove_reference_t&lt;_Ty&gt;*&gt;&gt; { // (pointer type can be formed)
    using type = remove_reference_t&lt;_Ty&gt;*;
};

template &lt;class _Ty&gt;
struct add_pointer {
    using type = typename _Add_pointer&lt;_Ty&gt;::type;
};

template &lt;class _Ty&gt;
using add_pointer_t = typename _Add_pointer&lt;_Ty&gt;::type;

// TYPE PREDICATES
// STRUCT TEMPLATE is_array
template &lt;class&gt;
_INLINE_VAR constexpr bool is_array_v = false; // determine whether type argument is an array

template &lt;class _Ty, size_t _Nx&gt;
_INLINE_VAR constexpr bool is_array_v&lt;_Ty[_Nx]&gt; = true;

template &lt;class _Ty&gt;
_INLINE_VAR constexpr bool is_array_v&lt;_Ty[]&gt; = true;

template &lt;class _Ty&gt;
struct is_array : bool_constant&lt;is_array_v&lt;_Ty&gt;&gt; {};

// STRUCT TEMPLATE is_lvalue_reference
template &lt;class&gt;
_INLINE_VAR constexpr bool is_lvalue_reference_v = false; // determine whether type argument is an lvalue reference

template &lt;class _Ty&gt;
_INLINE_VAR constexpr bool is_lvalue_reference_v&lt;_Ty&amp;&gt; = true;

template &lt;class _Ty&gt;
struct is_lvalue_reference : bool_constant&lt;is_lvalue_reference_v&lt;_Ty&gt;&gt; {};

// STRUCT TEMPLATE is_rvalue_reference
template &lt;class&gt;
_INLINE_VAR constexpr bool is_rvalue_reference_v = false; // determine whether type argument is an rvalue reference

template &lt;class _Ty&gt;
_INLINE_VAR constexpr bool is_rvalue_reference_v&lt;_Ty&amp;&amp;&gt; = true;

template &lt;class _Ty&gt;
struct is_rvalue_reference : bool_constant&lt;is_rvalue_reference_v&lt;_Ty&gt;&gt; {};

// STRUCT TEMPLATE is_reference
template &lt;class&gt;
_INLINE_VAR constexpr bool is_reference_v = false; // determine whether type argument is a reference

template &lt;class _Ty&gt;
_INLINE_VAR constexpr bool is_reference_v&lt;_Ty&amp;&gt; = true;

template &lt;class _Ty&gt;
_INLINE_VAR constexpr bool is_reference_v&lt;_Ty&amp;&amp;&gt; = true;

template &lt;class _Ty&gt;
struct is_reference : bool_constant&lt;is_reference_v&lt;_Ty&gt;&gt; {};

// STRUCT TEMPLATE is_member_object_pointer
template &lt;class _Ty, bool _Pmf = _Is_memfunptr&lt;_Ty&gt;::_Bool_type::value&gt;
struct _Is_member_object_pointer { // determine whether _Ty is a pointer to member object
    static constexpr bool value = false;
};

template &lt;class _Ty1, class _Ty2&gt;
struct _Is_member_object_pointer&lt;_Ty1 _Ty2::*, false&gt; {
    static constexpr bool value = true;
    using _Class_type           = _Ty2;
};

template &lt;class _Ty&gt;
_INLINE_VAR constexpr bool is_member_object_pointer_v = // determine whether _Ty is a pointer to member object
    _Is_member_object_pointer&lt;remove_cv_t&lt;_Ty&gt;&gt;::value;

template &lt;class _Ty&gt;
struct is_member_object_pointer : bool_constant&lt;is_member_object_pointer_v&lt;_Ty&gt;&gt; {};

// STRUCT TEMPLATE is_member_function_pointer
template &lt;class _Ty&gt;
_INLINE_VAR constexpr bool is_member_function_pointer_v = // determine whether _Ty is a pointer to member function
    _Is_memfunptr&lt;remove_cv_t&lt;_Ty&gt;&gt;::_Bool_type::value;

template &lt;class _Ty&gt;
struct is_member_function_pointer : bool_constant&lt;is_member_function_pointer_v&lt;_Ty&gt;&gt; {};

// STRUCT TEMPLATE is_pointer
template &lt;class&gt;
_INLINE_VAR constexpr bool is_pointer_v = false; // determine whether _Ty is a pointer

template &lt;class _Ty&gt;
_INLINE_VAR constexpr bool is_pointer_v&lt;_Ty*&gt; = true;

template &lt;class _Ty&gt;
_INLINE_VAR constexpr bool is_pointer_v&lt;_Ty* const&gt; = true;

template &lt;class _Ty&gt;
_INLINE_VAR constexpr bool is_pointer_v&lt;_Ty* volatile&gt; = true;

template &lt;class _Ty&gt;
_INLINE_VAR constexpr bool is_pointer_v&lt;_Ty* const volatile&gt; = true;

template &lt;class _Ty&gt;
struct is_pointer : bool_constant&lt;is_pointer_v&lt;_Ty&gt;&gt; {};

// STRUCT TEMPLATE is_null_pointer
template &lt;class _Ty&gt;
_INLINE_VAR constexpr bool is_null_pointer_v =
    is_same_v&lt;remove_cv_t&lt;_Ty&gt;, nullptr_t&gt;; // determine whether _Ty is cv-qualified nullptr_t

template &lt;class _Ty&gt;
struct is_null_pointer : bool_constant&lt;is_null_pointer_v&lt;_Ty&gt;&gt; {};

// STRUCT TEMPLATE is_union
template &lt;class _Ty&gt;
struct is_union : bool_constant&lt;__is_union(_Ty)&gt; {}; // determine whether _Ty is a union

template &lt;class _Ty&gt;
_INLINE_VAR constexpr bool is_union_v = __is_union(_Ty);

// STRUCT TEMPLATE is_class
template &lt;class _Ty&gt;
struct is_class : bool_constant&lt;__is_class(_Ty)&gt; {}; // determine whether _Ty is a class

template &lt;class _Ty&gt;
_INLINE_VAR constexpr bool is_class_v = __is_class(_Ty);

// STRUCT TEMPLATE is_fundamental
template &lt;class _Ty&gt;
_INLINE_VAR constexpr bool is_fundamental_v = is_arithmetic_v&lt;_Ty&gt; || is_void_v&lt;_Ty&gt; || is_null_pointer_v&lt;_Ty&gt;;

template &lt;class _Ty&gt;
struct is_fundamental : bool_constant&lt;is_fundamental_v&lt;_Ty&gt;&gt; {}; // determine whether _Ty is a fundamental type

// STRUCT TEMPLATE is_object
template &lt;class _Ty&gt;
_INLINE_VAR constexpr bool is_object_v = !is_function_v&lt;_Ty&gt; &amp;&amp; !is_reference_v&lt;_Ty&gt; &amp;&amp; !is_void_v&lt;_Ty&gt;;

template &lt;class _Ty&gt;
struct is_object : bool_constant&lt;is_object_v&lt;_Ty&gt;&gt; {}; // determine whether _Ty is an object type

// STRUCT TEMPLATE is_convertible
template &lt;class _From, class _To&gt;
struct is_convertible : bool_constant&lt;__is_convertible_to(_From, _To)&gt; {
    // determine whether _From is convertible to _To
};

template &lt;class _From, class _To&gt;
_INLINE_VAR constexpr bool is_convertible_v = __is_convertible_to(_From, _To);

// STRUCT TEMPLATE is_enum
template &lt;class _Ty&gt;
struct is_enum : bool_constant&lt;__is_enum(_Ty)&gt; {}; // determine whether _Ty is an enumerated type

template &lt;class _Ty&gt;
_INLINE_VAR constexpr bool is_enum_v = __is_enum(_Ty);

// STRUCT TEMPLATE is_compound
template &lt;class _Ty&gt;
struct is_compound : bool_constant&lt;!is_fundamental_v&lt;_Ty&gt;&gt; {}; // determine whether _Ty is a compound type

template &lt;class _Ty&gt;
_INLINE_VAR constexpr bool is_compound_v = !is_fundamental_v&lt;_Ty&gt;;

// STRUCT TEMPLATE is_member_pointer
template &lt;class _Ty&gt;
_INLINE_VAR constexpr bool is_member_pointer_v = is_member_object_pointer_v&lt;_Ty&gt; || is_member_function_pointer_v&lt;_Ty&gt;;

template &lt;class _Ty&gt;
struct is_member_pointer : bool_constant&lt;is_member_pointer_v&lt;_Ty&gt;&gt; {}; // determine whether _Ty is a pointer to member

// STRUCT TEMPLATE is_scalar
template &lt;class _Ty&gt;
_INLINE_VAR constexpr bool is_scalar_v = // determine whether _Ty is a scalar type
    is_arithmetic_v&lt;_Ty&gt; || is_enum_v&lt;_Ty&gt; || is_pointer_v&lt;_Ty&gt; || is_member_pointer_v&lt;_Ty&gt; || is_null_pointer_v&lt;_Ty&gt;;

template &lt;class _Ty&gt;
struct is_scalar : bool_constant&lt;is_scalar_v&lt;_Ty&gt;&gt; {};

// STRUCT TEMPLATE is_const
template &lt;class&gt;
_INLINE_VAR constexpr bool is_const_v = false; // determine whether type argument is const qualified

template &lt;class _Ty&gt;
_INLINE_VAR constexpr bool is_const_v&lt;const _Ty&gt; = true;

template &lt;class _Ty&gt;
struct is_const : bool_constant&lt;is_const_v&lt;_Ty&gt;&gt; {};

// STRUCT TEMPLATE is_volatile
template &lt;class&gt;
_INLINE_VAR constexpr bool is_volatile_v = false; // determine whether type argument is volatile qualified

template &lt;class _Ty&gt;
_INLINE_VAR constexpr bool is_volatile_v&lt;volatile _Ty&gt; = true;

template &lt;class _Ty&gt;
struct is_volatile : bool_constant&lt;is_volatile_v&lt;_Ty&gt;&gt; {};

// STRUCT TEMPLATE is_pod
template &lt;class _Ty&gt;
struct is_pod : bool_constant&lt;__is_pod(_Ty)&gt; {}; // determine whether _Ty is a POD type

template &lt;class _Ty&gt;
_INLINE_VAR constexpr bool is_pod_v = __is_pod(_Ty);

// STRUCT TEMPLATE is_empty
template &lt;class _Ty&gt;
struct is_empty : bool_constant&lt;__is_empty(_Ty)&gt; {}; // determine whether _Ty is an empty class

template &lt;class _Ty&gt;
_INLINE_VAR constexpr bool is_empty_v = __is_empty(_Ty);

// STRUCT TEMPLATE is_polymorphic
template &lt;class _Ty&gt;
struct is_polymorphic : bool_constant&lt;__is_polymorphic(_Ty)&gt; {}; // determine whether _Ty is a polymorphic type

template &lt;class _Ty&gt;
_INLINE_VAR constexpr bool is_polymorphic_v = __is_polymorphic(_Ty);

// STRUCT TEMPLATE is_abstract
template &lt;class _Ty&gt;
struct is_abstract : bool_constant&lt;__is_abstract(_Ty)&gt; {}; // determine whether _Ty is an abstract class

template &lt;class _Ty&gt;
_INLINE_VAR constexpr bool is_abstract_v = __is_abstract(_Ty);

// STRUCT TEMPLATE is_final
template &lt;class _Ty&gt;
struct is_final : bool_constant&lt;__is_final(_Ty)&gt; {}; // determine whether _Ty is a final class

template &lt;class _Ty&gt;
_INLINE_VAR constexpr bool is_final_v = __is_final(_Ty);

// STRUCT TEMPLATE is_standard_layout
template &lt;class _Ty&gt;
struct is_standard_layout : bool_constant&lt;__is_standard_layout(_Ty)&gt; {}; // determine whether _Ty is standard layout

template &lt;class _Ty&gt;
_INLINE_VAR constexpr bool is_standard_layout_v = __is_standard_layout(_Ty);

// STRUCT TEMPLATE is_literal_type
template &lt;class _Ty&gt;
struct _CXX17_DEPRECATE_IS_LITERAL_TYPE is_literal_type : bool_constant&lt;__is_literal_type(_Ty)&gt; {
    // determine whether _Ty is a literal type
};

template &lt;class _Ty&gt;
_CXX17_DEPRECATE_IS_LITERAL_TYPE _INLINE_VAR constexpr bool is_literal_type_v = __is_literal_type(_Ty);

// STRUCT TEMPLATE is_trivial
#if 1 // TRANSITION, VSO#119526 and LLVM#41915
template &lt;class _Ty&gt;
struct is_trivial : bool_constant&lt;__is_trivially_constructible(_Ty) &amp;&amp; __is_trivially_copyable(_Ty)&gt; {
    // determine whether _Ty is a trivial type
};

template &lt;class _Ty&gt;
_INLINE_VAR constexpr bool is_trivial_v = __is_trivially_constructible(_Ty) &amp;&amp; __is_trivially_copyable(_Ty);
#else // ^^^ workaround / no workaround vvv
template &lt;class _Ty&gt;
struct is_trivial : bool_constant&lt;__is_trivial(_Ty)&gt; {}; // determine whether _Ty is a trivial type

template &lt;class _Ty&gt;
_INLINE_VAR constexpr bool is_trivial_v = __is_trivial(_Ty);
#endif // TRANSITION

// STRUCT TEMPLATE is_trivially_copyable
template &lt;class _Ty&gt;
struct is_trivially_copyable : bool_constant&lt;__is_trivially_copyable(_Ty)&gt; {
    // determine whether _Ty is a trivially copyable type
};

template &lt;class _Ty&gt;
_INLINE_VAR constexpr bool is_trivially_copyable_v = __is_trivially_copyable(_Ty);

// STRUCT TEMPLATE has_virtual_destructor
template &lt;class _Ty&gt;
struct has_virtual_destructor : bool_constant&lt;__has_virtual_destructor(_Ty)&gt; {
    // determine whether _Ty has a virtual destructor
};

template &lt;class _Ty&gt;
_INLINE_VAR constexpr bool has_virtual_destructor_v = __has_virtual_destructor(_Ty);

#if _HAS_CXX17
// STRUCT TEMPLATE has_unique_object_representations
template &lt;class _Ty&gt;
struct has_unique_object_representations : bool_constant&lt;__has_unique_object_representations(_Ty)&gt; {
    // determine whether _Ty has unique object representations
};

template &lt;class _Ty&gt;
_INLINE_VAR constexpr bool has_unique_object_representations_v = __has_unique_object_representations(_Ty);

// STRUCT TEMPLATE is_aggregate
template &lt;class _Ty&gt;
struct is_aggregate : bool_constant&lt;__is_aggregate(_Ty)&gt; {}; // determine whether _Ty is an aggregate

template &lt;class _Ty&gt;
_INLINE_VAR constexpr bool is_aggregate_v = __is_aggregate(_Ty);
#endif // _HAS_CXX17

// CONSTRUCTIBLE/ASSIGNABLE TRAITS
// STRUCT TEMPLATE is_constructible
template &lt;class _Ty, class... _Args&gt;
struct is_constructible : bool_constant&lt;__is_constructible(_Ty, _Args...)&gt; {
    // determine whether _Ty can be direct-initialized with _Args...
};

template &lt;class _Ty, class... _Args&gt;
_INLINE_VAR constexpr bool is_constructible_v = __is_constructible(_Ty, _Args...);

// STRUCT TEMPLATE is_copy_constructible
template &lt;class _Ty&gt;
struct is_copy_constructible : bool_constant&lt;__is_constructible(_Ty, add_lvalue_reference_t&lt;const _Ty&gt;)&gt; {
    // determine whether _Ty can be direct-initialized with an lvalue const _Ty
};

template &lt;class _Ty&gt;
_INLINE_VAR constexpr bool is_copy_constructible_v = __is_constructible(_Ty, add_lvalue_reference_t&lt;const _Ty&gt;);

// STRUCT TEMPLATE is_default_constructible
template &lt;class _Ty&gt;
struct is_default_constructible : bool_constant&lt;__is_constructible(_Ty)&gt; {
    // determine whether _Ty can be value-initialized
};

template &lt;class _Ty&gt;
_INLINE_VAR constexpr bool is_default_constructible_v = __is_constructible(_Ty);

// STRUCT TEMPLATE _Is_implicitly_default_constructible
template &lt;class _Ty, class = void&gt;
struct _Is_implicitly_default_constructible : false_type {
    // determine whether _Ty can be copy-initialized with {}
};

template &lt;class _Ty&gt;
void _Implicitly_default_construct(const _Ty&amp;);

template &lt;class _Ty&gt;
struct _Is_implicitly_default_constructible&lt;_Ty, void_t&lt;decltype(_Implicitly_default_construct&lt;_Ty&gt;({}))&gt;&gt; : true_type {
};

// STRUCT TEMPLATE is_move_constructible
template &lt;class _Ty&gt;
struct is_move_constructible : bool_constant&lt;__is_constructible(_Ty, _Ty)&gt; {
    // determine whether _Ty can be direct-initialized from an rvalue _Ty
};

template &lt;class _Ty&gt;
_INLINE_VAR constexpr bool is_move_constructible_v = __is_constructible(_Ty, _Ty);

// STRUCT TEMPLATE is_assignable
template &lt;class _To, class _From&gt;
struct is_assignable : bool_constant&lt;__is_assignable(_To, _From)&gt; {}; // determine whether _From can be assigned to _To

template &lt;class _To, class _From&gt;
_INLINE_VAR constexpr bool is_assignable_v = __is_assignable(_To, _From);

// STRUCT TEMPLATE is_copy_assignable
template &lt;class _Ty&gt;
struct is_copy_assignable
    : bool_constant&lt;__is_assignable(add_lvalue_reference_t&lt;_Ty&gt;, add_lvalue_reference_t&lt;const _Ty&gt;)&gt; {
    // determine whether an lvalue const _Ty can be assigned to an lvalue _Ty
};

template &lt;class _Ty&gt;
_INLINE_VAR constexpr bool is_copy_assignable_v = __is_assignable(
    add_lvalue_reference_t&lt;_Ty&gt;, add_lvalue_reference_t&lt;const _Ty&gt;);

#if defined(_IS_ASSIGNABLE_NOCHECK_SUPPORTED) &amp;&amp; !defined(__CUDACC__)
template &lt;class _Ty&gt;
struct _Is_copy_assignable_no_precondition_check
    : bool_constant&lt;__is_assignable_no_precondition_check(
          add_lvalue_reference_t&lt;_Ty&gt;, add_lvalue_reference_t&lt;const _Ty&gt;)&gt; {};

template &lt;class _Ty&gt;
_INLINE_VAR constexpr bool _Is_copy_assignable_unchecked_v = __is_assignable_no_precondition_check(
    add_lvalue_reference_t&lt;_Ty&gt;, add_lvalue_reference_t&lt;const _Ty&gt;);
#else // ^^^ Use intrinsic / intrinsic not supported vvv
template &lt;class _Ty&gt;
using _Is_copy_assignable_no_precondition_check = is_copy_assignable&lt;_Ty&gt;;

template &lt;class _Ty&gt;
_INLINE_VAR constexpr bool _Is_copy_assignable_unchecked_v = is_copy_assignable_v&lt;_Ty&gt;;
#endif // defined(_IS_ASSIGNABLE_NOCHECK_SUPPORTED) &amp;&amp; !defined(__CUDACC__)

// STRUCT TEMPLATE is_move_assignable
template &lt;class _Ty&gt;
struct is_move_assignable : bool_constant&lt;__is_assignable(add_lvalue_reference_t&lt;_Ty&gt;, _Ty)&gt; {
    // determine whether an rvalue _Ty can be assigned to an lvalue _Ty
};

template &lt;class _Ty&gt;
_INLINE_VAR constexpr bool is_move_assignable_v = __is_assignable(add_lvalue_reference_t&lt;_Ty&gt;, _Ty);

#if defined(_IS_ASSIGNABLE_NOCHECK_SUPPORTED) &amp;&amp; !defined(__CUDACC__)
template &lt;class _Ty&gt;
struct _Is_move_assignable_no_precondition_check
    : bool_constant&lt;__is_assignable_no_precondition_check(add_lvalue_reference_t&lt;_Ty&gt;, _Ty)&gt; {};

template &lt;class _Ty&gt;
_INLINE_VAR constexpr bool _Is_move_assignable_unchecked_v = __is_assignable_no_precondition_check(
    add_lvalue_reference_t&lt;_Ty&gt;, _Ty);
#else // ^^^ Use intrinsic / intrinsic not supported vvv
template &lt;class _Ty&gt;
using _Is_move_assignable_no_precondition_check = is_move_assignable&lt;_Ty&gt;;

template &lt;class _Ty&gt;
_INLINE_VAR constexpr bool _Is_move_assignable_unchecked_v = is_move_assignable_v&lt;_Ty&gt;;
#endif // defined(_IS_ASSIGNABLE_NOCHECK_SUPPORTED) &amp;&amp; !defined(__CUDACC__)

// STRUCT TEMPLATE is_destructible
template &lt;class _Ty&gt;
struct is_destructible : bool_constant&lt;__is_destructible(_Ty)&gt; {
    // true iff remove_all_extents_t&lt;_Ty&gt; is a reference type, or can be explicitly destroyed
};

template &lt;class _Ty&gt;
_INLINE_VAR constexpr bool is_destructible_v = __is_destructible(_Ty);

// TRIVIAL TRAITS
// STRUCT TEMPLATE is_trivially_constructible
template &lt;class _Ty, class... _Args&gt;
struct is_trivially_constructible : bool_constant&lt;__is_trivially_constructible(_Ty, _Args...)&gt; {
    // determine whether direct-initialization of _Ty with _Args... is trivial
};

template &lt;class _Ty, class... _Args&gt;
_INLINE_VAR constexpr bool is_trivially_constructible_v = __is_trivially_constructible(_Ty, _Args...);

// STRUCT TEMPLATE is_trivially_copy_constructible
template &lt;class _Ty&gt;
struct is_trivially_copy_constructible
    : bool_constant&lt;__is_trivially_constructible(_Ty, add_lvalue_reference_t&lt;const _Ty&gt;)&gt; {
    // determine whether direct-initialization of _Ty with an lvalue const _Ty is trivial
};

template &lt;class _Ty&gt;
_INLINE_VAR constexpr bool is_trivially_copy_constructible_v = __is_trivially_constructible(
    _Ty, add_lvalue_reference_t&lt;const _Ty&gt;);

// STRUCT TEMPLATE is_trivially_default_constructible
template &lt;class _Ty&gt;
struct is_trivially_default_constructible : bool_constant&lt;__is_trivially_constructible(_Ty)&gt; {
    // determine whether value-initialization of _Ty is trivial
};

template &lt;class _Ty&gt;
_INLINE_VAR constexpr bool is_trivially_default_constructible_v = __is_trivially_constructible(_Ty);

// STRUCT TEMPLATE is_trivially_move_constructible
template &lt;class _Ty&gt;
struct is_trivially_move_constructible : bool_constant&lt;__is_trivially_constructible(_Ty, _Ty)&gt; {
    // determine whether direct-initialization of _Ty with an rvalue _Ty is trivial
};

template &lt;class _Ty&gt;
_INLINE_VAR constexpr bool is_trivially_move_constructible_v = __is_trivially_constructible(_Ty, _Ty);

// STRUCT TEMPLATE is_trivially_assignable
template &lt;class _To, class _From&gt;
struct is_trivially_assignable : bool_constant&lt;__is_trivially_assignable(_To, _From)&gt; {
    // determine whether _From can be trivially assigned to _To
};

template &lt;class _To, class _From&gt;
_INLINE_VAR constexpr bool is_trivially_assignable_v = __is_trivially_assignable(_To, _From);

// STRUCT TEMPLATE is_trivially_copy_assignable
template &lt;class _Ty&gt;
struct is_trivially_copy_assignable
    : bool_constant&lt;__is_trivially_assignable(add_lvalue_reference_t&lt;_Ty&gt;, add_lvalue_reference_t&lt;const _Ty&gt;)&gt; {
    // determine whether an lvalue const _Ty can be trivially assigned to an lvalue _Ty
};

template &lt;class _Ty&gt;
_INLINE_VAR constexpr bool is_trivially_copy_assignable_v = __is_trivially_assignable(
    add_lvalue_reference_t&lt;_Ty&gt;, add_lvalue_reference_t&lt;const _Ty&gt;);

// STRUCT TEMPLATE is_trivially_move_assignable
template &lt;class _Ty&gt;
struct is_trivially_move_assignable : bool_constant&lt;__is_trivially_assignable(add_lvalue_reference_t&lt;_Ty&gt;, _Ty)&gt; {
    // determine whether an rvalue _Ty can be trivially assigned to an lvalue _Ty
};

template &lt;class _Ty&gt;
_INLINE_VAR constexpr bool is_trivially_move_assignable_v = __is_trivially_assignable(add_lvalue_reference_t&lt;_Ty&gt;, _Ty);

// STRUCT TEMPLATE is_trivially_destructible
template &lt;class _Ty&gt;
struct is_trivially_destructible : bool_constant&lt;__is_trivially_destructible(_Ty)&gt; {
    // determine whether remove_all_extents_t&lt;_Ty&gt; is a reference type or can trivially be explicitly destroyed
};

template &lt;class _Ty&gt;
_INLINE_VAR constexpr bool is_trivially_destructible_v = __is_trivially_destructible(_Ty);

// NOTHROW TRAITS
// STRUCT TEMPLATE is_nothrow_constructible
template &lt;class _Ty, class... _Args&gt;
struct is_nothrow_constructible : bool_constant&lt;__is_nothrow_constructible(_Ty, _Args...)&gt; {
    // determine whether direct-initialization of _Ty from _Args... is both valid and not potentially-throwing
};

template &lt;class _Ty, class... _Args&gt;
_INLINE_VAR constexpr bool is_nothrow_constructible_v = __is_nothrow_constructible(_Ty, _Args...);

// STRUCT TEMPLATE is_nothrow_copy_constructible
template &lt;class _Ty&gt;
struct is_nothrow_copy_constructible
    : bool_constant&lt;__is_nothrow_constructible(_Ty, add_lvalue_reference_t&lt;const _Ty&gt;)&gt; {
    // determine whether direct-initialization of _Ty from an lvalue const _Ty is both valid
    // and not potentially-throwing
};

template &lt;class _Ty&gt;
_INLINE_VAR constexpr bool is_nothrow_copy_constructible_v = __is_nothrow_constructible(
    _Ty, add_lvalue_reference_t&lt;const _Ty&gt;);

// STRUCT TEMPLATE is_nothrow_default_constructible
template &lt;class _Ty&gt;
struct is_nothrow_default_constructible : bool_constant&lt;__is_nothrow_constructible(_Ty)&gt; {
    // determine whether value-initialization of _Ty is both valid and not potentially-throwing
};

template &lt;class _Ty&gt;
_INLINE_VAR constexpr bool is_nothrow_default_constructible_v = __is_nothrow_constructible(_Ty);

// STRUCT TEMPLATE is_nothrow_move_constructible
template &lt;class _Ty&gt;
struct is_nothrow_move_constructible : bool_constant&lt;__is_nothrow_constructible(_Ty, _Ty)&gt; {
    // determine whether direct-initialization of _Ty from an rvalue _Ty is both valid and not potentially-throwing
};

template &lt;class _Ty&gt;
_INLINE_VAR constexpr bool is_nothrow_move_constructible_v = __is_nothrow_constructible(_Ty, _Ty);

// STRUCT TEMPLATE is_nothrow_assignable
template &lt;class _To, class _From&gt;
struct is_nothrow_assignable : bool_constant&lt;__is_nothrow_assignable(_To, _From)&gt; {
    // determine whether assignment of _From to _To is both valid and not potentially-throwing
};

template &lt;class _To, class _From&gt;
_INLINE_VAR constexpr bool is_nothrow_assignable_v = __is_nothrow_assignable(_To, _From);

// STRUCT TEMPLATE is_nothrow_copy_assignable
template &lt;class _Ty&gt;
struct is_nothrow_copy_assignable
    : bool_constant&lt;__is_nothrow_assignable(add_lvalue_reference_t&lt;_Ty&gt;, add_lvalue_reference_t&lt;const _Ty&gt;)&gt; {
    // determine whether assignment of an lvalue const _Ty to an lvalue _Ty is both valid and not potentially-throwing
};

template &lt;class _Ty&gt;
_INLINE_VAR constexpr bool is_nothrow_copy_assignable_v = __is_nothrow_assignable(
    add_lvalue_reference_t&lt;_Ty&gt;, add_lvalue_reference_t&lt;const _Ty&gt;);

// STRUCT TEMPLATE is_nothrow_move_assignable
template &lt;class _Ty&gt;
struct is_nothrow_move_assignable : bool_constant&lt;__is_nothrow_assignable(add_lvalue_reference_t&lt;_Ty&gt;, _Ty)&gt; {
    // determine whether assignment of an rvalue _Ty to an lvalue _Ty is both valid and not potentially-throwing
};

template &lt;class _Ty&gt;
_INLINE_VAR constexpr bool is_nothrow_move_assignable_v = __is_nothrow_assignable(add_lvalue_reference_t&lt;_Ty&gt;, _Ty);

// STRUCT TEMPLATE is_nothrow_destructible
template &lt;class _Ty&gt;
struct is_nothrow_destructible : bool_constant&lt;__is_nothrow_destructible(_Ty)&gt; {
    // determine whether remove_all_extents_t&lt;_Ty&gt; is a reference type or has
    // non-potentially-throwing explicit destruction
};

template &lt;class _Ty&gt;
_INLINE_VAR constexpr bool is_nothrow_destructible_v = __is_nothrow_destructible(_Ty);

// STRUCT TEMPLATE is_signed
template &lt;class _Ty, bool = is_integral_v&lt;_Ty&gt;&gt;
struct _Sign_base { // determine whether integral type _Ty is signed or unsigned
    using _Uty = remove_cv_t&lt;_Ty&gt;;

    static constexpr bool _Signed   = _Uty(-1) &lt; _Uty(0);
    static constexpr bool _Unsigned = !_Signed;
};

template &lt;class _Ty&gt;
struct _Sign_base&lt;_Ty, false&gt; { // floating-point _Ty is signed
                                // non-arithmetic _Ty is neither signed nor unsigned
    static constexpr bool _Signed   = is_floating_point_v&lt;_Ty&gt;;
    static constexpr bool _Unsigned = false;
};

template &lt;class _Ty&gt;
struct is_signed : bool_constant&lt;_Sign_base&lt;_Ty&gt;::_Signed&gt; {}; // determine whether _Ty is a signed type

template &lt;class _Ty&gt;
_INLINE_VAR constexpr bool is_signed_v = _Sign_base&lt;_Ty&gt;::_Signed;

// STRUCT TEMPLATE is_unsigned
template &lt;class _Ty&gt;
struct is_unsigned : bool_constant&lt;_Sign_base&lt;_Ty&gt;::_Unsigned&gt; {}; // determine whether _Ty is an unsigned type

template &lt;class _Ty&gt;
_INLINE_VAR constexpr bool is_unsigned_v = _Sign_base&lt;_Ty&gt;::_Unsigned;

// VARIABLE TEMPLATE _Is_nonbool_integral
template &lt;class _Ty&gt;
_INLINE_VAR constexpr bool _Is_nonbool_integral = is_integral_v&lt;_Ty&gt; &amp;&amp; !is_same_v&lt;remove_cv_t&lt;_Ty&gt;, bool&gt;;

// STRUCT TEMPLATE make_signed
template &lt;bool&gt;
struct _Select { // Select between aliases that extract either their first or second parameter
    template &lt;class _Ty1, class&gt;
    using _Apply = _Ty1;
};

template &lt;&gt;
struct _Select&lt;false&gt; {
    template &lt;class, class _Ty2&gt;
    using _Apply = _Ty2;
};

template &lt;size_t&gt;
struct _Make_signed2; // Choose make_signed strategy by type size

template &lt;&gt;
struct _Make_signed2&lt;1&gt; {
    template &lt;class&gt;
    using _Apply = signed char;
};

template &lt;&gt;
struct _Make_signed2&lt;2&gt; {
    template &lt;class&gt;
    using _Apply = short;
};

template &lt;&gt;
struct _Make_signed2&lt;4&gt; {
    template &lt;class _Ty&gt;
    using _Apply = // assumes LLP64
        typename _Select&lt;is_same_v&lt;_Ty, long&gt; || is_same_v&lt;_Ty, unsigned long&gt;&gt;::template _Apply&lt;long, int&gt;;
};

template &lt;&gt;
struct _Make_signed2&lt;8&gt; {
    template &lt;class&gt;
    using _Apply = long long;
};

template &lt;class _Ty&gt;
using _Make_signed1 = // signed partner to cv-unqualified _Ty
    typename _Make_signed2&lt;sizeof(_Ty)&gt;::template _Apply&lt;_Ty&gt;;

template &lt;class _Ty&gt;
struct make_signed { // signed partner to _Ty
    static_assert(_Is_nonbool_integral&lt;_Ty&gt; || is_enum_v&lt;_Ty&gt;,
        "make_signed&lt;T&gt; requires that T shall be a (possibly cv-qualified) "
        "integral type or enumeration but not a bool type.");

    using type = typename remove_cv&lt;_Ty&gt;::template _Apply&lt;_Make_signed1&gt;;
};

template &lt;class _Ty&gt;
using make_signed_t = typename make_signed&lt;_Ty&gt;::type;

// STRUCT TEMPLATE make_unsigned
template &lt;size_t&gt;
struct _Make_unsigned2; // Choose make_unsigned strategy by type size

template &lt;&gt;
struct _Make_unsigned2&lt;1&gt; {
    template &lt;class&gt;
    using _Apply = unsigned char;
};

template &lt;&gt;
struct _Make_unsigned2&lt;2&gt; {
    template &lt;class&gt;
    using _Apply = unsigned short;
};

template &lt;&gt;
struct _Make_unsigned2&lt;4&gt; {
    template &lt;class _Ty&gt;
    using _Apply = // assumes LLP64
        typename _Select&lt;is_same_v&lt;_Ty, long&gt; || is_same_v&lt;_Ty, unsigned long&gt;&gt;::template _Apply&lt;unsigned long,
            unsigned int&gt;;
};

template &lt;&gt;
struct _Make_unsigned2&lt;8&gt; {
    template &lt;class&gt;
    using _Apply = unsigned long long;
};

template &lt;class _Ty&gt;
using _Make_unsigned1 = // unsigned partner to cv-unqualified _Ty
    typename _Make_unsigned2&lt;sizeof(_Ty)&gt;::template _Apply&lt;_Ty&gt;;

template &lt;class _Ty&gt;
struct make_unsigned { // unsigned partner to _Ty
    static_assert(_Is_nonbool_integral&lt;_Ty&gt; || is_enum_v&lt;_Ty&gt;,
        "make_unsigned&lt;T&gt; requires that T shall be a (possibly cv-qualified) "
        "integral type or enumeration but not a bool type.");

    using type = typename remove_cv&lt;_Ty&gt;::template _Apply&lt;_Make_unsigned1&gt;;
};

template &lt;class _Ty&gt;
using make_unsigned_t = typename make_unsigned&lt;_Ty&gt;::type;

// FUNCTION TEMPLATE _Unsigned_value
template &lt;class _Rep&gt;
constexpr make_unsigned_t&lt;_Rep&gt; _Unsigned_value(_Rep _Val) { // makes _Val unsigned
    return static_cast&lt;make_unsigned_t&lt;_Rep&gt;&gt;(_Val);
}

// STRUCT TEMPLATE alignment_of
template &lt;class _Ty&gt;
struct alignment_of : integral_constant&lt;size_t, alignof(_Ty)&gt; {}; // determine alignment of _Ty

template &lt;class _Ty&gt;
_INLINE_VAR constexpr size_t alignment_of_v = alignof(_Ty);

// STRUCT TEMPLATE aligned_storage
#define _FITS(_Ty) _Align &lt;= alignof(_Ty)
#define _NEXT_ALIGN(_Ty) using type = typename _Aligned&lt;_Len, _Align, _Ty, _FITS(_Ty)&gt;::type

template &lt;class _Ty, size_t _Len&gt;
union _Align_type { // union with size _Len bytes and alignment of _Ty
    _Ty _Val;
    char _Pad[_Len];
};

template &lt;size_t _Len, size_t _Align, class _Ty, bool _Ok&gt;
struct _Aligned; // define type with size _Len and alignment _Ty

template &lt;size_t _Len, size_t _Align, class _Ty&gt;
struct _Aligned&lt;_Len, _Align, _Ty, true&gt; {
    using type = _Align_type&lt;_Ty, _Len&gt;;
};

template &lt;size_t _Len, size_t _Align&gt;
struct _Aligned&lt;_Len, _Align, double, false&gt; {
#ifdef _ENABLE_EXTENDED_ALIGNED_STORAGE
    struct type {
        alignas(_Align) char _Space[_Len];
    };
#else // ^^^ _ENABLE_EXTENDED_ALIGNED_STORAGE / !_ENABLE_EXTENDED_ALIGNED_STORAGE vvv
#ifndef _DISABLE_EXTENDED_ALIGNED_STORAGE
    static_assert(_Always_false&lt;_Aligned&gt;,
        "You've instantiated std::aligned_storage&lt;Len, Align&gt; with an extended alignment (in other "
        "words, Align &gt; alignof(max_align_t)). Before VS 2017 15.8, the member \"type\" would "
        "non-conformingly have an alignment of only alignof(max_align_t). VS 2017 15.8 was fixed to "
        "handle this correctly, but the fix inherently changes layout and breaks binary compatibility "
        "(*only* for uses of aligned_storage with extended alignments). "
        "Please define either "
        "(1) _ENABLE_EXTENDED_ALIGNED_STORAGE to acknowledge that you understand this message and "
        "that you actually want a type with an extended alignment, or "
        "(2) _DISABLE_EXTENDED_ALIGNED_STORAGE to silence this message and get the old non-conforming "
        "behavior.");
#endif // !_DISABLE_EXTENDED_ALIGNED_STORAGE
    using type = _Align_type&lt;max_align_t, _Len&gt;;
#endif // _ENABLE_EXTENDED_ALIGNED_STORAGE
};

template &lt;size_t _Len, size_t _Align&gt;
struct _Aligned&lt;_Len, _Align, int, false&gt; {
    _NEXT_ALIGN(double);
};

template &lt;size_t _Len, size_t _Align&gt;
struct _Aligned&lt;_Len, _Align, short, false&gt; {
    _NEXT_ALIGN(int);
};

template &lt;size_t _Len, size_t _Align&gt;
struct _Aligned&lt;_Len, _Align, char, false&gt; {
    _NEXT_ALIGN(short);
};

template &lt;size_t _Len, size_t _Align = alignof(max_align_t)&gt;
struct aligned_storage { // define type with size _Len and alignment _Align
    using type = typename _Aligned&lt;_Len, _Align, char, _FITS(char)&gt;::type;
};

#undef _FITS
#undef _NEXT_ALIGN

template &lt;size_t _Len, size_t _Align = alignof(max_align_t)&gt;
using aligned_storage_t = typename aligned_storage&lt;_Len, _Align&gt;::type;

// STRUCT TEMPLATE aligned_union
template &lt;size_t... _Vals&gt;
struct _Maximum;

template &lt;&gt;
struct _Maximum&lt;&gt; : integral_constant&lt;size_t, 0&gt; {}; // maximum of nothing is 0

template &lt;size_t _Val&gt;
struct _Maximum&lt;_Val&gt; : integral_constant&lt;size_t, _Val&gt; {}; // maximum of _Val is _Val

template &lt;size_t _First, size_t _Second, size_t... _Rest&gt;
struct _Maximum&lt;_First, _Second, _Rest...&gt; : _Maximum&lt;(_First &lt; _Second ? _Second : _First), _Rest...&gt;::type {
    // find maximum value in _First, _Second, _Rest...
};

template &lt;size_t _Len, class... _Types&gt;
struct aligned_union { // define type with size at least _Len, for storing anything in _Types
    static constexpr size_t _Max_len        = _Maximum&lt;_Len, sizeof(_Types)...&gt;::value; // NOT sizeof...(_Types)
    static constexpr size_t alignment_value = _Maximum&lt;alignof(_Types)...&gt;::value;

    using type = aligned_storage_t&lt;_Max_len, alignment_value&gt;;
};

template &lt;size_t _Len, class... _Types&gt;
using aligned_union_t = typename aligned_union&lt;_Len, _Types...&gt;::type;

// STRUCT TEMPLATE underlying_type
template &lt;class _Ty&gt;
struct underlying_type { // determine underlying type for enum
    using type = __underlying_type(_Ty);
};

template &lt;class _Ty&gt;
using underlying_type_t = typename underlying_type&lt;_Ty&gt;::type;

// STRUCT TEMPLATE rank
template &lt;class _Ty&gt;
_INLINE_VAR constexpr size_t rank_v = 0; // determine number of dimensions of array _Ty

template &lt;class _Ty, size_t _Nx&gt;
_INLINE_VAR constexpr size_t rank_v&lt;_Ty[_Nx]&gt; = rank_v&lt;_Ty&gt; + 1;

template &lt;class _Ty&gt;
_INLINE_VAR constexpr size_t rank_v&lt;_Ty[]&gt; = rank_v&lt;_Ty&gt; + 1;

template &lt;class _Ty&gt;
struct rank : integral_constant&lt;size_t, rank_v&lt;_Ty&gt;&gt; {};

// STRUCT TEMPLATE extent
template &lt;class _Ty, unsigned int _Ix = 0&gt;
_INLINE_VAR constexpr size_t extent_v = 0; // determine extent of dimension _Ix of array _Ty

template &lt;class _Ty, size_t _Nx&gt;
_INLINE_VAR constexpr size_t extent_v&lt;_Ty[_Nx], 0&gt; = _Nx;

template &lt;class _Ty, unsigned int _Ix, size_t _Nx&gt;
_INLINE_VAR constexpr size_t extent_v&lt;_Ty[_Nx], _Ix&gt; = extent_v&lt;_Ty, _Ix - 1&gt;;

template &lt;class _Ty, unsigned int _Ix&gt;
_INLINE_VAR constexpr size_t extent_v&lt;_Ty[], _Ix&gt; = extent_v&lt;_Ty, _Ix - 1&gt;;

template &lt;class _Ty, unsigned int _Ix = 0&gt;
struct extent : integral_constant&lt;size_t, extent_v&lt;_Ty, _Ix&gt;&gt; {};

// STRUCT TEMPLATE is_base_of
template &lt;class _Base, class _Derived&gt;
struct is_base_of : bool_constant&lt;__is_base_of(_Base, _Derived)&gt; {
    // determine whether _Base is a base of or the same as _Derived
};

template &lt;class _Base, class _Derived&gt;
_INLINE_VAR constexpr bool is_base_of_v = __is_base_of(_Base, _Derived);

// STRUCT TEMPLATE decay
template &lt;class _Ty&gt;
struct decay { // determines decayed version of _Ty
    using _Ty1 = remove_reference_t&lt;_Ty&gt;;
    using _Ty2 = typename _Select&lt;is_function_v&lt;_Ty1&gt;&gt;::template _Apply&lt;add_pointer&lt;_Ty1&gt;, remove_cv&lt;_Ty1&gt;&gt;;
    using type = typename _Select&lt;is_array_v&lt;_Ty1&gt;&gt;::template _Apply&lt;add_pointer&lt;remove_extent_t&lt;_Ty1&gt;&gt;, _Ty2&gt;::type;
};

template &lt;class _Ty&gt;
using decay_t = typename decay&lt;_Ty&gt;::type;

// ALIAS TEMPLATE _Conditional_type
template &lt;class _Ty1, class _Ty2&gt;
using _Conditional_type = decltype(false ? _STD declval&lt;_Ty1&gt;() : _STD declval&lt;_Ty2&gt;());

// STRUCT TEMPLATE common_type
#if _HAS_CXX20
template &lt;class _Ty1, class _Ty2, class = void&gt;
struct _Const_lvalue_cond_oper {};

// N4810 [meta.trans.other]/3.3.4 (per P/R of pending LWG issue): "Otherwise, if remove_cvref_t&lt;/**/&gt; denotes a type..."
template &lt;class _Ty1, class _Ty2&gt;
struct _Const_lvalue_cond_oper&lt;_Ty1, _Ty2, void_t&lt;_Conditional_type&lt;const _Ty1&amp;, const _Ty2&amp;&gt;&gt;&gt; {
    using type = remove_cvref_t&lt;_Conditional_type&lt;const _Ty1&amp;, const _Ty2&amp;&gt;&gt;;
};

template &lt;class _Ty1, class _Ty2, class = void&gt;
struct _Decayed_cond_oper : _Const_lvalue_cond_oper&lt;_Ty1, _Ty2&gt; {};
#else // ^^^ &gt;= C++20 / &lt;= C++17 vvv
template &lt;class _Ty1, class _Ty2, class = void&gt;
struct _Decayed_cond_oper {};
#endif // _HAS_CXX20

template &lt;class _Ty1, class _Ty2&gt;
struct _Decayed_cond_oper&lt;_Ty1, _Ty2, void_t&lt;_Conditional_type&lt;_Ty1, _Ty2&gt;&gt;&gt; {
    using type = decay_t&lt;_Conditional_type&lt;_Ty1, _Ty2&gt;&gt;;
};

template &lt;class... _Ty&gt;
struct common_type;

template &lt;class... _Ty&gt;
using common_type_t = typename common_type&lt;_Ty...&gt;::type;

template &lt;&gt;
struct common_type&lt;&gt; {};

template &lt;class _Ty1&gt;
struct common_type&lt;_Ty1&gt; : common_type&lt;_Ty1, _Ty1&gt; {};

template &lt;class _Ty1, class _Ty2, class _Decayed1 = decay_t&lt;_Ty1&gt;, class _Decayed2 = decay_t&lt;_Ty2&gt;&gt;
struct _Common_type2 : common_type&lt;_Decayed1, _Decayed2&gt; {};

template &lt;class _Ty1, class _Ty2&gt;
struct _Common_type2&lt;_Ty1, _Ty2, _Ty1, _Ty2&gt; : _Decayed_cond_oper&lt;_Ty1, _Ty2&gt; {};

template &lt;class _Ty1, class _Ty2&gt;
struct common_type&lt;_Ty1, _Ty2&gt; : _Common_type2&lt;_Ty1, _Ty2&gt; {};

template &lt;class _Void, class _Ty1, class _Ty2, class... _Rest&gt;
struct _Common_type3 {};

template &lt;class _Ty1, class _Ty2, class... _Rest&gt;
struct _Common_type3&lt;void_t&lt;common_type_t&lt;_Ty1, _Ty2&gt;&gt;, _Ty1, _Ty2, _Rest...&gt;
    : common_type&lt;common_type_t&lt;_Ty1, _Ty2&gt;, _Rest...&gt; {};

template &lt;class _Ty1, class _Ty2, class... _Rest&gt;
struct common_type&lt;_Ty1, _Ty2, _Rest...&gt; : _Common_type3&lt;void, _Ty1, _Ty2, _Rest...&gt; {};

#if _HAS_CXX20
// STRUCT TEMPLATE basic_common_reference
template &lt;class, class, template &lt;class&gt; class, template &lt;class&gt; class&gt;
struct basic_common_reference {};

// FUNCTION TEMPLATE _Returns_exactly
template &lt;class _Ty&gt;
_Ty _Returns_exactly() noexcept; // not defined

// ALIAS TEMPLATE _Cond_res
template &lt;class _Ty1, class _Ty2&gt;
using _Cond_res = // N4810 [meta.trans.other]/2.4
    decltype(false ? _Returns_exactly&lt;_Ty1&gt;() : _Returns_exactly&lt;_Ty2&gt;());

// ALIAS TEMPLATE _Copy_cv
template &lt;class _From&gt;
struct _Copy_cv_impl {
    template &lt;class _To&gt;
    using _Apply = _To;
};
template &lt;class _From&gt;
struct _Copy_cv_impl&lt;const _From&gt; {
    template &lt;class _To&gt;
    using _Apply = const _To;
};
template &lt;class _From&gt;
struct _Copy_cv_impl&lt;volatile _From&gt; {
    template &lt;class _To&gt;
    using _Apply = volatile _To;
};
template &lt;class _From&gt;
struct _Copy_cv_impl&lt;const volatile _From&gt; {
    template &lt;class _To&gt;
    using _Apply = const volatile _To;
};
template &lt;class _From, class _To&gt;
using _Copy_cv = // N4810 [meta.trans.other]/2.3
    typename _Copy_cv_impl&lt;_From&gt;::template _Apply&lt;_To&gt;;

// STRUCT TEMPLATE _Add_qualifiers
template &lt;class _Ty1&gt;
struct _Add_qualifiers { // _Add_qualifiers&lt;A&gt;::template _Apply is XREF(A) from N4810 [meta.trans.other]/2.1
    template &lt;class _Ty2&gt;
    using _Apply = _Copy_cv&lt;_Ty1, _Ty2&gt;;
};
template &lt;class _Ty1&gt;
struct _Add_qualifiers&lt;_Ty1&amp;&gt; {
    template &lt;class _Ty2&gt;
    using _Apply = add_lvalue_reference_t&lt;_Copy_cv&lt;_Ty1, _Ty2&gt;&gt;;
};
template &lt;class _Ty1&gt;
struct _Add_qualifiers&lt;_Ty1&amp;&amp;&gt; {
    template &lt;class _Ty2&gt;
    using _Apply = add_rvalue_reference_t&lt;_Copy_cv&lt;_Ty1, _Ty2&gt;&gt;;
};

// STRUCT TEMPLATE common_reference
template &lt;class...&gt;
struct common_reference;

// ALIAS TEMPLATE common_reference_t
template &lt;class... _Types&gt;
using common_reference_t = typename common_reference&lt;_Types...&gt;::type;

// N4810 [meta.trans.other]/5.1: "If sizeof...(T) is zero ..."
template &lt;&gt;
struct common_reference&lt;&gt; {};

// N4810 [meta.trans.other]/5.2: "...if sizeof...(T) is one ..."
template &lt;class _Ty&gt;
struct common_reference&lt;_Ty&gt; {
    using type = _Ty;
};

// N4810 [meta.trans.other]/5.3: "...if sizeof...(T) is two..."

// N4810 [meta.trans.other]/5.3.4: "if common_type_t&lt;T1, T2&gt; is well-formed..."
// N4810 [meta.trans.other]/5.3.5: "Otherwise, there shall be no member type."
template &lt;class _Ty1, class _Ty2, class = void&gt;
struct _Common_reference2C : common_type&lt;_Ty1, _Ty2&gt; {};

// N4810 [meta.trans.other]/5.3.3: "if COND_RES(T1, T2) is well-formed..."
template &lt;class _Ty1, class _Ty2&gt;
struct _Common_reference2C&lt;_Ty1, _Ty2, void_t&lt;_Cond_res&lt;_Ty1, _Ty2&gt;&gt;&gt; {
    using type = _Cond_res&lt;_Ty1, _Ty2&gt;;
};

// N4810 [meta.trans.other]/5.3.2: "if basic_common_reference&lt;[...]&gt;::type is well-formed..."
template &lt;class _Ty1, class _Ty2&gt;
using _Basic_specialization = typename basic_common_reference&lt;remove_cvref_t&lt;_Ty1&gt;, remove_cvref_t&lt;_Ty2&gt;,
    _Add_qualifiers&lt;_Ty1&gt;::template _Apply, _Add_qualifiers&lt;_Ty2&gt;::template _Apply&gt;::type;

template &lt;class _Ty1, class _Ty2, class = void&gt;
struct _Common_reference2B : _Common_reference2C&lt;_Ty1, _Ty2&gt; {};

template &lt;class _Ty1, class _Ty2&gt;
struct _Common_reference2B&lt;_Ty1, _Ty2, void_t&lt;_Basic_specialization&lt;_Ty1, _Ty2&gt;&gt;&gt; {
    using type = _Basic_specialization&lt;_Ty1, _Ty2&gt;;
};

// N4810 [meta.trans.other]/5.3.1: "If T1 and T2 are reference types and COMMON_REF(T1, T2) is well-formed..."
template &lt;class _Ty1, class _Ty2, class = void&gt;
struct _Common_reference2A : _Common_reference2B&lt;_Ty1, _Ty2&gt; {};

template &lt;class _Ty1, class _Ty2, class _Result = _Cond_res&lt;_Copy_cv&lt;_Ty1, _Ty2&gt;&amp;, _Copy_cv&lt;_Ty2, _Ty1&gt;&amp;&gt;,
#ifdef __CUDACC__ // TRANSITION
    enable_if_t&lt;is_lvalue_reference&lt;_Result&gt;::value, int&gt; = 0&gt;
#else // ^^^ workaround / no workaround vvv
    enable_if_t&lt;is_lvalue_reference_v&lt;_Result&gt;, int&gt; = 0&gt;
#endif // TRANSITION
using _LL_common_ref = _Result;

template &lt;class _Ty1, class _Ty2&gt;
struct _Common_reference2A&lt;_Ty1&amp;, _Ty2&amp;, void_t&lt;_LL_common_ref&lt;_Ty1, _Ty2&gt;&gt;&gt; {
    using type = _LL_common_ref&lt;_Ty1, _Ty2&gt;; // "both lvalues" case from N4810 [meta.trans.other]/2.5
};

template &lt;class _Ty1, class _Ty2&gt;
struct _Common_reference2A&lt;_Ty1&amp;&amp;, _Ty2&amp;, enable_if_t&lt;is_convertible_v&lt;_Ty1&amp;&amp;, _LL_common_ref&lt;const _Ty1, _Ty2&gt;&gt;&gt;&gt; {
    using type = _LL_common_ref&lt;const _Ty1, _Ty2&gt;; // "rvalue and lvalue" case from N4810 [meta.trans.other]/2.7
};

template &lt;class _Ty1, class _Ty2&gt;
struct _Common_reference2A&lt;_Ty1&amp;, _Ty2&amp;&amp;, enable_if_t&lt;is_convertible_v&lt;_Ty2&amp;&amp;, _LL_common_ref&lt;const _Ty2, _Ty1&gt;&gt;&gt;&gt; {
    using type = _LL_common_ref&lt;const _Ty2, _Ty1&gt;; // "lvalue and rvalue" case from N4810 [meta.trans.other]/2.8
};

template &lt;class _Ty1, class _Ty2&gt;
using _RR_common_ref = remove_reference_t&lt;_LL_common_ref&lt;_Ty1, _Ty2&gt;&gt;&amp;&amp;;

template &lt;class _Ty1, class _Ty2&gt;
struct _Common_reference2A&lt;_Ty1&amp;&amp;, _Ty2&amp;&amp;,
    enable_if_t&lt;
        is_convertible_v&lt;_Ty1&amp;&amp;, _RR_common_ref&lt;_Ty1, _Ty2&gt;&gt; &amp;&amp; is_convertible_v&lt;_Ty2&amp;&amp;, _RR_common_ref&lt;_Ty1, _Ty2&gt;&gt;&gt;&gt; {
    using type = _RR_common_ref&lt;_Ty1, _Ty2&gt;; // "both rvalues" case from N4810 [meta.trans.other]/2.6
};

template &lt;class _Ty1, class _Ty2&gt;
struct common_reference&lt;_Ty1, _Ty2&gt; : _Common_reference2A&lt;_Ty1, _Ty2&gt; {};

// N4810 [meta.trans.other]/5.4: "if sizeof...(T) is greater than two..."
template &lt;class _Void, class _Ty1, class _Ty2, class... _Types&gt;
struct _Fold_common_reference {};
template &lt;class _Ty1, class _Ty2, class... _Types&gt;
struct _Fold_common_reference&lt;void_t&lt;common_reference_t&lt;_Ty1, _Ty2&gt;&gt;, _Ty1, _Ty2, _Types...&gt;
    : common_reference&lt;common_reference_t&lt;_Ty1, _Ty2&gt;, _Types...&gt; {};

template &lt;class _Ty1, class _Ty2, class _Ty3, class... _Rest&gt;
struct common_reference&lt;_Ty1, _Ty2, _Ty3, _Rest...&gt; : _Fold_common_reference&lt;void, _Ty1, _Ty2, _Ty3, _Rest...&gt; {};
#endif // _HAS_CXX20

// STRUCT TEMPLATE _Identity
template &lt;class _Ty&gt;
struct _Identity {
    using type = _Ty;
};
template &lt;class _Ty&gt;
using _Identity_t = typename _Identity&lt;_Ty&gt;::type;

#if _HAS_CXX20
// STRUCT TEMPLATE type_identity
template &lt;class _Ty&gt;
struct type_identity {
    using type = _Ty;
};
template &lt;class _Ty&gt;
using type_identity_t = typename type_identity&lt;_Ty&gt;::type;
#endif // _HAS_CXX20

// STRUCT TEMPLATE _Is_specialization
template &lt;class _Type, template &lt;class...&gt; class _Template&gt;
_INLINE_VAR constexpr bool _Is_specialization_v = false; // true if and only if _Type is a specialization of _Template
template &lt;template &lt;class...&gt; class _Template, class... _Types&gt;
_INLINE_VAR constexpr bool _Is_specialization_v&lt;_Template&lt;_Types...&gt;, _Template&gt; = true;

template &lt;class _Type, template &lt;class...&gt; class _Template&gt;
struct _Is_specialization : bool_constant&lt;_Is_specialization_v&lt;_Type, _Template&gt;&gt; {};

// FUNCTION TEMPLATE forward
template &lt;class _Ty&gt;
_NODISCARD constexpr _Ty&amp;&amp; forward(
    remove_reference_t&lt;_Ty&gt;&amp; _Arg) noexcept { // forward an lvalue as either an lvalue or an rvalue
    return static_cast&lt;_Ty&amp;&amp;&gt;(_Arg);
}

template &lt;class _Ty&gt;
_NODISCARD constexpr _Ty&amp;&amp; forward(remove_reference_t&lt;_Ty&gt;&amp;&amp; _Arg) noexcept { // forward an rvalue as an rvalue
    static_assert(!is_lvalue_reference_v&lt;_Ty&gt;, "bad forward call");
    return static_cast&lt;_Ty&amp;&amp;&gt;(_Arg);
}

// FUNCTION TEMPLATE move
template &lt;class _Ty&gt;
<span style = "background-color:#fdd">_NODISCARD constexpr remove_reference_t&lt;_Ty&gt;&amp;&amp; move(_Ty&amp;&amp; _Arg) noexcept { // forward _Arg as movable
    return static_cast&lt;remove_reference_t&lt;_Ty&gt;&amp;&amp;&gt;(_Arg);
}</span>

// FUNCTION TEMPLATE move_if_noexcept
template &lt;class _Ty&gt;
_NODISCARD constexpr conditional_t&lt;!is_nothrow_move_constructible_v&lt;_Ty&gt; &amp;&amp; is_copy_constructible_v&lt;_Ty&gt;, const _Ty&amp;,
    _Ty&amp;&amp;&gt;
    move_if_noexcept(_Ty&amp; _Arg) noexcept { // forward _Arg as movable, sometimes
    return _STD move(_Arg);
}

template &lt;class _Ty&gt;
class reference_wrapper;

#define _CONCATX(x, y) x##y
#define _CONCAT(x, y) _CONCATX(x, y)

#define _IMPLEMENT_INVOKE(NAME_PREFIX, CONSTEXPR)                                                                      \
    /* FUNCTION TEMPLATE invoke */                                                                                     \
    struct _CONCAT(NAME_PREFIX, _Invoker_pmf_object) { /* INVOKE a pointer to member function on an object */          \
        template &lt;class _Decayed, class _Ty1, class... _Types2&gt;                                                        \
        static CONSTEXPR auto _Call(_Decayed _Pmf, _Ty1&amp;&amp; _Arg1, _Types2&amp;&amp;... _Args2) noexcept(                        \
            noexcept((_STD forward&lt;_Ty1&gt;(_Arg1).*_Pmf)(_STD forward&lt;_Types2&gt;(_Args2)...)))                             \
            -&gt; decltype((_STD forward&lt;_Ty1&gt;(_Arg1).*_Pmf)(                                                             \
                _STD forward&lt;_Types2&gt;(_Args2)...)) { /* INVOKE a pointer to member function on an object */            \
            return (_STD forward&lt;_Ty1&gt;(_Arg1).*_Pmf)(_STD forward&lt;_Types2&gt;(_Args2)...);                                \
        }                                                                                                              \
    };                                                                                                                 \
                                                                                                                       \
    struct _CONCAT(                                                                                                    \
        NAME_PREFIX, _Invoker_pmf_refwrap) { /* INVOKE a pointer to member function on a reference_wrapper */          \
        template &lt;class _Decayed, class _Ty1, class... _Types2&gt;                                                        \
        static CONSTEXPR auto _Call(_Decayed _Pmf, _Ty1&amp;&amp; _Arg1, _Types2&amp;&amp;... _Args2) noexcept(                        \
            noexcept((_STD forward&lt;_Ty1&gt;(_Arg1).get().*_Pmf)(_STD forward&lt;_Types2&gt;(_Args2)...)))                       \
            -&gt; decltype((_STD forward&lt;_Ty1&gt;(_Arg1).get().*_Pmf)(                                                       \
                _STD forward&lt;_Types2&gt;(_Args2)...)) { /* INVOKE a pointer to member function on a reference_wrapper */  \
            return (_STD forward&lt;_Ty1&gt;(_Arg1).get().*_Pmf)(_STD forward&lt;_Types2&gt;(_Args2)...);                          \
        }                                                                                                              \
    };                                                                                                                 \
                                                                                                                       \
    struct _CONCAT(NAME_PREFIX, _Invoker_pmf_pointer) { /* INVOKE a pointer to member function on a [smart] pointer */ \
        template &lt;class _Decayed, class _Ty1, class... _Types2&gt;                                                        \
        static CONSTEXPR auto _Call(_Decayed _Pmf, _Ty1&amp;&amp; _Arg1, _Types2&amp;&amp;... _Args2) noexcept(                        \
            noexcept(((*_STD forward&lt;_Ty1&gt;(_Arg1)).*_Pmf)(_STD forward&lt;_Types2&gt;(_Args2)...)))                          \
            -&gt; decltype(((*_STD forward&lt;_Ty1&gt;(_Arg1)).*_Pmf)(                                                          \
                _STD forward&lt;_Types2&gt;(_Args2)...)) { /* INVOKE a pointer to member function on a [smart] pointer */    \
            return ((*_STD forward&lt;_Ty1&gt;(_Arg1)).*_Pmf)(_STD forward&lt;_Types2&gt;(_Args2)...);                             \
        }                                                                                                              \
    };                                                                                                                 \
                                                                                                                       \
    struct _CONCAT(NAME_PREFIX, _Invoker_pmd_object) { /* INVOKE a pointer to member data on an object */              \
        template &lt;class _Decayed, class _Ty1&gt;                                                                          \
        static CONSTEXPR auto _Call(_Decayed _Pmd, _Ty1&amp;&amp; _Arg1) noexcept(noexcept(_STD forward&lt;_Ty1&gt;(_Arg1).*_Pmd))   \
            -&gt; decltype(_STD forward&lt;_Ty1&gt;(_Arg1).*_Pmd) { /* INVOKE a pointer to member data on an object */          \
            return _STD forward&lt;_Ty1&gt;(_Arg1).*_Pmd;                                                                    \
        }                                                                                                              \
    };                                                                                                                 \
                                                                                                                       \
    struct _CONCAT(NAME_PREFIX, _Invoker_pmd_refwrap) { /* INVOKE a pointer to member data on a reference_wrapper */   \
        template &lt;class _Decayed, class _Ty1&gt;                                                                          \
        static CONSTEXPR auto _Call(_Decayed _Pmd, _Ty1&amp;&amp; _Arg1) noexcept(                                             \
            noexcept(_STD forward&lt;_Ty1&gt;(_Arg1).get().*_Pmd))                                                           \
            -&gt; decltype(                                                                                               \
                _STD forward&lt;_Ty1&gt;(_Arg1).get().*_Pmd) { /* INVOKE a pointer to member data on a reference_wrapper */  \
            return _STD forward&lt;_Ty1&gt;(_Arg1).get().*_Pmd;                                                              \
        }                                                                                                              \
    };                                                                                                                 \
                                                                                                                       \
    struct _CONCAT(NAME_PREFIX, _Invoker_pmd_pointer) { /* INVOKE a pointer to member data on a [smart] pointer */     \
        template &lt;class _Decayed, class _Ty1&gt;                                                                          \
        static CONSTEXPR auto _Call(_Decayed _Pmd, _Ty1&amp;&amp; _Arg1) noexcept(                                             \
            noexcept((*_STD forward&lt;_Ty1&gt;(_Arg1)).*_Pmd))                                                              \
            -&gt; decltype(                                                                                               \
                (*_STD forward&lt;_Ty1&gt;(_Arg1)).*_Pmd) { /* INVOKE a pointer to member data on a [smart] pointer */       \
            return (*_STD forward&lt;_Ty1&gt;(_Arg1)).*_Pmd;                                                                 \
        }                                                                                                              \
    };                                                                                                                 \
                                                                                                                       \
    struct _CONCAT(NAME_PREFIX, _Invoker_functor) { /* INVOKE a function object */                                     \
        template &lt;class _Callable, class... _Types&gt;                                                                    \
        static CONSTEXPR auto _Call(_Callable&amp;&amp; _Obj, _Types&amp;&amp;... _Args) noexcept(                                     \
            noexcept(_STD forward&lt;_Callable&gt;(_Obj)(_STD forward&lt;_Types&gt;(_Args)...)))                                   \
            -&gt; decltype(                                                                                               \
                _STD forward&lt;_Callable&gt;(_Obj)(_STD forward&lt;_Types&gt;(_Args)...)) { /* INVOKE a function object */        \
            return _STD forward&lt;_Callable&gt;(_Obj)(_STD forward&lt;_Types&gt;(_Args)...);                                      \
        }                                                                                                              \
    };                                                                                                                 \
                                                                                                                       \
    template &lt;class _Callable, class _Ty1, class _Removed_cvref = _Remove_cvref_t&lt;_Callable&gt;,                          \
        bool _Is_pmf = is_member_function_pointer_v&lt;_Removed_cvref&gt;,                                                   \
        bool _Is_pmd = is_member_object_pointer_v&lt;_Removed_cvref&gt;&gt;                                                     \
    struct _CONCAT(NAME_PREFIX, _Invoker1);                                                                            \
                                                                                                                       \
    template &lt;class _Callable, class _Ty1, class _Removed_cvref&gt;                                                       \
    struct _CONCAT(NAME_PREFIX, _Invoker1)&lt;_Callable, _Ty1, _Removed_cvref, true, false&gt;                               \
        : conditional_t&lt;is_base_of_v&lt;typename _Is_memfunptr&lt;_Removed_cvref&gt;::_Class_type, remove_reference_t&lt;_Ty1&gt;&gt;,   \
              _CONCAT(NAME_PREFIX, _Invoker_pmf_object),                                                               \
              conditional_t&lt;_Is_specialization_v&lt;_Remove_cvref_t&lt;_Ty1&gt;, reference_wrapper&gt;,                            \
                  _CONCAT(NAME_PREFIX, _Invoker_pmf_refwrap),                                                          \
                  _CONCAT(NAME_PREFIX, _Invoker_pmf_pointer)&gt;&gt; { /* pointer to member function */                      \
    };                                                                                                                 \
                                                                                                                       \
    template &lt;class _Callable, class _Ty1, class _Removed_cvref&gt;                                                       \
    struct _CONCAT(NAME_PREFIX, _Invoker1)&lt;_Callable, _Ty1, _Removed_cvref, false, true&gt;                               \
        : conditional_t&lt;                                                                                               \
              is_base_of_v&lt;typename _Is_member_object_pointer&lt;_Removed_cvref&gt;::_Class_type, remove_reference_t&lt;_Ty1&gt;&gt;, \
              _CONCAT(NAME_PREFIX, _Invoker_pmd_object),                                                               \
              conditional_t&lt;_Is_specialization_v&lt;_Remove_cvref_t&lt;_Ty1&gt;, reference_wrapper&gt;,                            \
                  _CONCAT(NAME_PREFIX, _Invoker_pmd_refwrap),                                                          \
                  _CONCAT(NAME_PREFIX, _Invoker_pmd_pointer)&gt;&gt; { /* pointer to member data */                          \
    };                                                                                                                 \
                                                                                                                       \
    template &lt;class _Callable, class _Ty1, class _Removed_cvref&gt;                                                       \
    struct _CONCAT(NAME_PREFIX, _Invoker1)&lt;_Callable, _Ty1, _Removed_cvref, false, false&gt;                              \
        : _CONCAT(NAME_PREFIX, _Invoker_functor) { /* function object */                                               \
    };                                                                                                                 \
                                                                                                                       \
    template &lt;class _Callable, class... _Types&gt;                                                                        \
    struct _CONCAT(NAME_PREFIX, _Invoker);                                                                             \
                                                                                                                       \
    template &lt;class _Callable&gt;                                                                                         \
    struct _CONCAT(NAME_PREFIX, _Invoker)&lt;_Callable&gt; : _CONCAT(NAME_PREFIX, _Invoker_functor) { /* zero arguments */   \
    };                                                                                                                 \
                                                                                                                       \
    template &lt;class _Callable, class _Ty1, class... _Types2&gt;                                                           \
    struct _CONCAT(NAME_PREFIX, _Invoker)&lt;_Callable, _Ty1, _Types2...&gt;                                                 \
        : _CONCAT(NAME_PREFIX, _Invoker1)&lt;_Callable, _Ty1&gt; { /* one or more arguments */                               \
    };                                                                                                                 \
                                                                                                                       \
    template &lt;class _Callable, class... _Types&gt;                                                                        \
    CONSTEXPR auto _CONCAT(NAME_PREFIX, invoke)(_Callable &amp;&amp; _Obj, _Types &amp;&amp; ... _Args) noexcept(                      \
        noexcept(_CONCAT(NAME_PREFIX, _Invoker) &lt; _Callable,                                                           \
            _Types... &gt; ::_Call(_STD forward&lt;_Callable&gt;(_Obj), _STD forward&lt;_Types&gt;(_Args)...)))                       \
        -&gt;decltype(_CONCAT(NAME_PREFIX, _Invoker) &lt; _Callable,                                                         \
            _Types... &gt; ::_Call(                                                                                       \
                _STD forward&lt;_Callable&gt;(_Obj), _STD forward&lt;_Types&gt;(_Args)...)) { /* INVOKE a callable object */       \
        return _CONCAT(NAME_PREFIX, _Invoker)&lt;_Callable, _Types...&gt;::_Call(                                            \
            _STD forward&lt;_Callable&gt;(_Obj), _STD forward&lt;_Types&gt;(_Args)...);                                            \
    }

_IMPLEMENT_INVOKE(_EMPTY_ARGUMENT, inline)

#if _HAS_CXX17
// constexpr IMPLEMENTATION OF invoke
_IMPLEMENT_INVOKE(_C_, constexpr)
#endif // _HAS_CXX17

#undef _IMPLEMENT_INVOKE

template &lt;class _Rx, bool = is_void_v&lt;_Rx&gt;&gt;
struct _Invoker_ret {}; // helper to give INVOKE an explicit return type; avoids undesirable Expression SFINAE

struct _Unforced {}; // tag to distinguish bind() from bind&lt;R&gt;()

template &lt;class _Cv_void&gt;
struct _Invoker_ret&lt;_Cv_void, true&gt; { // selected for _Rx being cv void
    template &lt;class... _Valtys&gt;
    static void _Call(_Valtys&amp;&amp;... _Vals) { // INVOKE, "implicitly" converted to void
        _STD invoke(_STD forward&lt;_Valtys&gt;(_Vals)...);
    }
};

template &lt;class _Rx&gt;
struct _Invoker_ret&lt;_Rx, false&gt; { // selected for all _Rx other than cv void and _Unforced
    template &lt;class... _Valtys&gt;
    static _Rx _Call(_Valtys&amp;&amp;... _Vals) { // INVOKE, implicitly converted to _Rx
        return _STD invoke(_STD forward&lt;_Valtys&gt;(_Vals)...);
    }
};

template &lt;&gt;
struct _Invoker_ret&lt;_Unforced, false&gt; { // selected for _Rx being _Unforced
    template &lt;class... _Valtys&gt;
    static auto _Call(_Valtys&amp;&amp;... _Vals)
        -&gt; decltype(_STD invoke(_STD forward&lt;_Valtys&gt;(_Vals)...)) { // INVOKE, unchanged
        return _STD invoke(_STD forward&lt;_Valtys&gt;(_Vals)...);
    }
};


// TYPE TRAITS FOR invoke()
template &lt;class _To&gt;
void _Implicitly_convert_to(_To) noexcept; // not defined

#pragma warning(push)
#pragma warning(disable : 4242) // 'identifier': conversion from '_From' to '_To', possible loss of data (/Wall)
#pragma warning(disable : 4244) // 'argument': conversion from '_From' to '_To', possible loss of data
#pragma warning(disable : 4365) // 'argument': conversion from '_From' to '_To', signed/unsigned mismatch (/Wall)
template &lt;class _From, class _To, bool = is_convertible_v&lt;_From, _To&gt;, bool = is_void_v&lt;_To&gt;&gt;
_INLINE_VAR constexpr bool _Is_nothrow_convertible_v = noexcept(_Implicitly_convert_to&lt;_To&gt;(_STD declval&lt;_From&gt;()));
#pragma warning(pop)
template &lt;class _From, class _To, bool _IsVoid&gt;
_INLINE_VAR constexpr bool _Is_nothrow_convertible_v&lt;_From, _To, false, _IsVoid&gt; = false;

template &lt;class _From, class _To&gt;
_INLINE_VAR constexpr bool _Is_nothrow_convertible_v&lt;_From, _To, true, true&gt; = true;

template &lt;class _From, class _To&gt;
struct _Is_nothrow_convertible : bool_constant&lt;_Is_nothrow_convertible_v&lt;_From, _To&gt;&gt; {
    // determine whether _From is nothrow-convertible to _To
};

#if _HAS_CXX20
template &lt;class _From, class _To&gt;
inline constexpr bool is_nothrow_convertible_v = _Is_nothrow_convertible_v&lt;_From, _To&gt;;

template &lt;class _From, class _To&gt;
using is_nothrow_convertible = _Is_nothrow_convertible&lt;_From, _To&gt;;
#endif // _HAS_CXX20

template &lt;class _Void, class... _Types&gt;
struct _Invoke_traits { // selected when _Callable isn't callable with _Args
    using _Is_invocable         = false_type;
    using _Is_nothrow_invocable = false_type;
    template &lt;class _Rx&gt;
    using _Is_invocable_r = false_type;
    template &lt;class _Rx&gt;
    using _Is_nothrow_invocable_r = false_type;
};

template &lt;class... _Types&gt;
struct _Invoke_traits&lt;void_t&lt;decltype(_STD invoke(_STD declval&lt;_Types&gt;()...))&gt;,
    _Types...&gt; { // selected when _Callable is callable with _Args
    using type                  = decltype(_STD invoke(_STD declval&lt;_Types&gt;()...));
    using _Is_invocable         = true_type;
    using _Is_nothrow_invocable = bool_constant&lt;noexcept(_STD invoke(_STD declval&lt;_Types&gt;()...))&gt;;
    template &lt;class _Rx&gt;
    using _Is_invocable_r = bool_constant&lt;disjunction_v&lt;is_void&lt;_Rx&gt;, is_convertible&lt;type, _Rx&gt;&gt;&gt;;
    template &lt;class _Rx&gt;
    using _Is_nothrow_invocable_r = bool_constant&lt;
        conjunction_v&lt;_Is_nothrow_invocable, disjunction&lt;is_void&lt;_Rx&gt;, _Is_nothrow_convertible&lt;type, _Rx&gt;&gt;&gt;&gt;;
};

// STRUCT TEMPLATE result_of
template &lt;class _Fty&gt;
struct _CXX17_DEPRECATE_RESULT_OF result_of { // explain usage
    static_assert(_Always_false&lt;_Fty&gt;, "result_of&lt;CallableType&gt; is invalid; use "
                                       "result_of&lt;CallableType(zero or more argument types)&gt; instead.");
};

#define _RESULT_OF(CALL_OPT, X1, X2, X3)                                                                   \
    template &lt;class _Callable, class... _Args&gt;                                                             \
    struct _CXX17_DEPRECATE_RESULT_OF result_of&lt;_Callable CALL_OPT(_Args...)&gt;                              \
        : _Invoke_traits&lt;void, _Callable, _Args...&gt; { /* template to determine result of call operation */ \
    };

_NON_MEMBER_CALL(_RESULT_OF, X1, X2, X3)
#undef _RESULT_OF

_STL_DISABLE_DEPRECATED_WARNING
template &lt;class _Ty&gt;
using result_of_t _CXX17_DEPRECATE_RESULT_OF = typename result_of&lt;_Ty&gt;::type;
_STL_RESTORE_DEPRECATED_WARNING

template &lt;class _Callable, class... _Args&gt;
using _Invoke_result_t = typename _Invoke_traits&lt;void, _Callable, _Args...&gt;::type;

template &lt;class _Rx, class _Callable, class... _Args&gt;
using _Is_invocable_r_ = typename _Invoke_traits&lt;void, _Callable, _Args...&gt;::template _Is_invocable_r&lt;_Rx&gt;;

template &lt;class _Rx, class _Callable, class... _Args&gt;
struct _Is_invocable_r : _Is_invocable_r_&lt;_Rx, _Callable, _Args...&gt; {
    // determines whether _Callable is callable with _Args and return type _Rx
};

#if _HAS_CXX17
// STRUCT TEMPLATE invoke_result
template &lt;class _Callable, class... _Args&gt;
struct invoke_result : _Invoke_traits&lt;void, _Callable, _Args...&gt; {
    // determine the result type of invoking _Callable with _Args
};

template &lt;class _Callable, class... _Args&gt;
using invoke_result_t = typename _Invoke_traits&lt;void, _Callable, _Args...&gt;::type;

// STRUCT TEMPLATE is_invocable
template &lt;class _Callable, class... _Args&gt;
struct is_invocable : _Invoke_traits&lt;void, _Callable, _Args...&gt;::_Is_invocable {
    // determines whether _Callable is callable with _Args
};

template &lt;class _Callable, class... _Args&gt;
inline constexpr bool is_invocable_v = _Invoke_traits&lt;void, _Callable, _Args...&gt;::_Is_invocable::value;

// STRUCT TEMPLATE is_nothrow_invocable
template &lt;class _Callable, class... _Args&gt;
struct is_nothrow_invocable : _Invoke_traits&lt;void, _Callable, _Args...&gt;::_Is_nothrow_invocable {
    // determines whether _Callable is nothrow-callable with _Args
};

template &lt;class _Callable, class... _Args&gt;
inline constexpr bool is_nothrow_invocable_v = _Invoke_traits&lt;void, _Callable, _Args...&gt;::_Is_nothrow_invocable::value;

// STRUCT TEMPLATE is_invocable_r
template &lt;class _Rx, class _Callable, class... _Args&gt;
struct is_invocable_r : _Is_invocable_r_&lt;_Rx, _Callable, _Args...&gt; {
    // determines whether _Callable is callable with _Args and return type _Rx
};

template &lt;class _Rx, class _Callable, class... _Args&gt;
inline constexpr bool is_invocable_r_v = _Is_invocable_r_&lt;_Rx, _Callable, _Args...&gt;::value;

// STRUCT TEMPLATE is_nothrow_invocable_r
template &lt;class _Rx, class _Callable, class... _Args&gt;
struct is_nothrow_invocable_r : _Invoke_traits&lt;void, _Callable, _Args...&gt;::template _Is_nothrow_invocable_r&lt;_Rx&gt; {
    // determines whether _Callable is nothrow-callable with _Args and return type _Rx
};

template &lt;class _Rx, class _Callable, class... _Args&gt;
inline constexpr bool is_nothrow_invocable_r_v =
    _Invoke_traits&lt;void, _Callable, _Args...&gt;::template _Is_nothrow_invocable_r&lt;_Rx&gt;::value;
#endif // _HAS_CXX17


// STRUCT TEMPLATE _Weak_types
template &lt;class _Ty, class = void&gt;
struct _Weak_result_type {}; // default definition

_STL_DISABLE_DEPRECATED_WARNING
template &lt;class _Ty&gt;
struct _Weak_result_type&lt;_Ty, void_t&lt;typename _Ty::result_type&gt;&gt; { // defined if _Ty::result_type exists
    _CXX17_DEPRECATE_ADAPTOR_TYPEDEFS typedef typename _Ty::result_type result_type;
};
_STL_RESTORE_DEPRECATED_WARNING

template &lt;class _Ty, class = void&gt;
struct _Weak_argument_type : _Weak_result_type&lt;_Ty&gt; {}; // default definition

_STL_DISABLE_DEPRECATED_WARNING
template &lt;class _Ty&gt;
struct _Weak_argument_type&lt;_Ty, void_t&lt;typename _Ty::argument_type&gt;&gt;
    : _Weak_result_type&lt;_Ty&gt; { // defined if _Ty::argument_type exists
    _CXX17_DEPRECATE_ADAPTOR_TYPEDEFS typedef typename _Ty::argument_type argument_type;
};
_STL_RESTORE_DEPRECATED_WARNING

template &lt;class _Ty, class = void&gt;
struct _Weak_binary_args : _Weak_argument_type&lt;_Ty&gt; {}; // default definition

_STL_DISABLE_DEPRECATED_WARNING
template &lt;class _Ty&gt;
struct _Weak_binary_args&lt;_Ty, void_t&lt;typename _Ty::first_argument_type,
                                  typename _Ty::second_argument_type&gt;&gt;
    : _Weak_argument_type&lt;_Ty&gt; { // defined if both types exist
    _CXX17_DEPRECATE_ADAPTOR_TYPEDEFS typedef typename _Ty::first_argument_type first_argument_type;
    _CXX17_DEPRECATE_ADAPTOR_TYPEDEFS typedef typename _Ty::second_argument_type second_argument_type;
};
_STL_RESTORE_DEPRECATED_WARNING

template &lt;class _Ty&gt;
struct _Weak_types { // provide nested types (sometimes)
    using _Is_f_or_pf = _Is_function&lt;remove_pointer_t&lt;_Ty&gt;&gt;;
    using _Is_pmf     = _Is_memfunptr&lt;remove_cv_t&lt;_Ty&gt;&gt;;
    using type        = conditional_t&lt;is_function_v&lt;remove_pointer_t&lt;_Ty&gt;&gt;, _Is_f_or_pf,
        conditional_t&lt;is_member_function_pointer_v&lt;_Ty&gt;, _Is_pmf, _Weak_binary_args&lt;_Ty&gt;&gt;&gt;;
};

// CLASS TEMPLATE reference_wrapper
template &lt;class _Ty&gt;
void _Refwrap_ctor_fun(_Identity_t&lt;_Ty&amp;&gt;) noexcept;
template &lt;class _Ty&gt;
void _Refwrap_ctor_fun(_Identity_t&lt;_Ty&amp;&amp;&gt;) = delete;

template &lt;class _Ty, class _Uty, class = void&gt;
struct _Refwrap_has_ctor_from : false_type {};

template &lt;class _Ty, class _Uty&gt;
struct _Refwrap_has_ctor_from&lt;_Ty, _Uty, void_t&lt;decltype(_Refwrap_ctor_fun&lt;_Ty&gt;(_STD declval&lt;_Uty&gt;()))&gt;&gt; : true_type {};

template &lt;class _Ty&gt;
class reference_wrapper : public _Weak_types&lt;_Ty&gt;::type { // stand-in for an assignable reference
public:
    static_assert(is_object_v&lt;_Ty&gt; || is_function_v&lt;_Ty&gt;,
        "reference_wrapper&lt;T&gt; requires T to be an object type or a function type.");

    using type = _Ty;

    template &lt;class _Uty, enable_if_t&lt;conjunction_v&lt;negation&lt;is_same&lt;_Remove_cvref_t&lt;_Uty&gt;, reference_wrapper&gt;&gt;,
                                          _Refwrap_has_ctor_from&lt;_Ty, _Uty&gt;&gt;,
                              int&gt; = 0&gt;
    reference_wrapper(_Uty&amp;&amp; _Val) noexcept(noexcept(_Refwrap_ctor_fun&lt;_Ty&gt;(_STD declval&lt;_Uty&gt;()))) {
        _Ty&amp; _Ref = _STD forward&lt;_Uty&gt;(_Val);
        _Ptr      = _STD addressof(_Ref);
    }

    operator _Ty&amp;() const noexcept {
        return *_Ptr;
    }

    _NODISCARD _Ty&amp; get() const noexcept {
        return *_Ptr;
    }

    template &lt;class... _Types&gt;
    auto operator()(_Types&amp;&amp;... _Args) const -&gt; decltype(_STD invoke(get(), _STD forward&lt;_Types&gt;(_Args)...)) {
        return _STD invoke(get(), _STD forward&lt;_Types&gt;(_Args)...);
    }

private:
    _Ty* _Ptr;
};

#if _HAS_CXX17
template &lt;class _Ty&gt;
reference_wrapper(_Ty&amp;)-&gt;reference_wrapper&lt;_Ty&gt;;
#endif // _HAS_CXX17

// FUNCTION TEMPLATES ref AND cref
template &lt;class _Ty&gt;
_NODISCARD reference_wrapper&lt;_Ty&gt; ref(_Ty&amp; _Val) noexcept {
    return reference_wrapper&lt;_Ty&gt;(_Val);
}

template &lt;class _Ty&gt;
void ref(const _Ty&amp;&amp;) = delete;

template &lt;class _Ty&gt;
_NODISCARD reference_wrapper&lt;_Ty&gt; ref(reference_wrapper&lt;_Ty&gt; _Val) noexcept {
    return _STD ref(_Val.get());
}

template &lt;class _Ty&gt;
_NODISCARD reference_wrapper&lt;const _Ty&gt; cref(const _Ty&amp; _Val) noexcept {
    return reference_wrapper&lt;const _Ty&gt;(_Val);
}

template &lt;class _Ty&gt;
void cref(const _Ty&amp;&amp;) = delete;

template &lt;class _Ty&gt;
_NODISCARD reference_wrapper&lt;const _Ty&gt; cref(reference_wrapper&lt;_Ty&gt; _Val) noexcept {
    return _STD cref(_Val.get());
}

#if _HAS_CXX20
// STRUCT TEMPLATE unwrap_reference
template &lt;class _Ty&gt;
struct unwrap_reference {
    using type = _Ty;
};
template &lt;class _Ty&gt;
struct unwrap_reference&lt;reference_wrapper&lt;_Ty&gt;&gt; {
    using type = _Ty&amp;;
};
template &lt;class _Ty&gt;
using unwrap_reference_t = typename unwrap_reference&lt;_Ty&gt;::type;

// STRUCT TEMPLATE unwrap_ref_decay
template &lt;class _Ty&gt;
using unwrap_ref_decay_t = unwrap_reference_t&lt;decay_t&lt;_Ty&gt;&gt;;
template &lt;class _Ty&gt;
struct unwrap_ref_decay {
    using type = unwrap_ref_decay_t&lt;_Ty&gt;;
};
#endif // _HAS_CXX20

// STRUCT TEMPLATE _Is_swappable
template &lt;class _Ty&gt;
struct _Is_swappable;

// STRUCT TEMPLATE _Is_nothrow_swappable
template &lt;class _Ty&gt;
struct _Is_nothrow_swappable;

// FUNCTION TEMPLATE swap
#if _HAS_CXX17
template &lt;class _Ty, class = enable_if_t&lt;is_move_constructible_v&lt;_Ty&gt; &amp;&amp; is_move_assignable_v&lt;_Ty&gt;&gt;&gt;
#else // ^^^ _HAS_CXX17 / !_HAS_CXX17 vvv
template &lt;class _Ty, class = void&gt;
#endif // _HAS_CXX17
void swap(_Ty&amp;, _Ty&amp;) noexcept(is_nothrow_move_constructible_v&lt;_Ty&gt;&amp;&amp; is_nothrow_move_assignable_v&lt;_Ty&gt;);

template &lt;class _Ty, size_t _Size, class = enable_if_t&lt;_Is_swappable&lt;_Ty&gt;::value&gt;&gt;
void swap(_Ty (&amp;)[_Size], _Ty (&amp;)[_Size]) noexcept(_Is_nothrow_swappable&lt;_Ty&gt;::value);

// STRUCT TEMPLATE _Swappable_with_helper
template &lt;class _Ty1, class _Ty2, class = void&gt;
struct _Swappable_with_helper : false_type {}; // swap(declval&lt;_Ty1&gt;(), declval&lt;_Ty2&gt;()) is not valid

template &lt;class _Ty1, class _Ty2&gt;
struct _Swappable_with_helper&lt;_Ty1, _Ty2, void_t&lt;decltype(swap(_STD declval&lt;_Ty1&gt;(), _STD declval&lt;_Ty2&gt;()))&gt;&gt;
    : true_type {}; // swap(declval&lt;_Ty1&gt;(), declval&lt;_Ty2&gt;()) is valid

// STRUCT TEMPLATE _Is_swappable_with
template &lt;class _Ty1, class _Ty2&gt;
struct _Is_swappable_with
    : bool_constant&lt;conjunction_v&lt;_Swappable_with_helper&lt;_Ty1, _Ty2&gt;, _Swappable_with_helper&lt;_Ty2, _Ty1&gt;&gt;&gt; {
    // Determine if expressions with type and value category _Ty1 and _Ty2 can be swapped (and vice versa)
};

// STRUCT TEMPLATE _Is_swappable
template &lt;class _Ty&gt;
struct _Is_swappable : _Is_swappable_with&lt;add_lvalue_reference_t&lt;_Ty&gt;, add_lvalue_reference_t&lt;_Ty&gt;&gt;::type {
    // Determine if _Ty lvalues satisfy is_swappable_with
};

// STRUCT TEMPLATE _Swap_cannot_throw
template &lt;class _Ty1, class _Ty2&gt;
struct _Swap_cannot_throw : bool_constant&lt;noexcept(swap(_STD declval&lt;_Ty1&gt;(), _STD declval&lt;_Ty2&gt;()))
                                          &amp;&amp; noexcept(swap(_STD declval&lt;_Ty2&gt;(), _STD declval&lt;_Ty1&gt;()))&gt; {
    // Determine if expressions with type and value category _Ty1 and _Ty2
    // (presumed to satisfy is_swappable_with) can be swapped without emitting exceptions
};

// STRUCT TEMPLATE _Is_nothrow_swappable_with
template &lt;class _Ty1, class _Ty2&gt;
struct _Is_nothrow_swappable_with
    : bool_constant&lt;conjunction_v&lt;_Is_swappable_with&lt;_Ty1, _Ty2&gt;, _Swap_cannot_throw&lt;_Ty1, _Ty2&gt;&gt;&gt; {
    // Determine if expressions with type and value category _Ty1 and _Ty2
    // satisfy is_swappable_with, and can be swapped without emitting exceptions
};

// STRUCT TEMPLATE _Is_nothrow_swappable
template &lt;class _Ty&gt;
struct _Is_nothrow_swappable
    : _Is_nothrow_swappable_with&lt;add_lvalue_reference_t&lt;_Ty&gt;, add_lvalue_reference_t&lt;_Ty&gt;&gt;::type {
    // Determine if _Ty lvalues satisfy is_nothrow_swappable_with
};

#if _HAS_CXX17
// STRUCT TEMPLATE is_swappable_with
template &lt;class _Ty1, class _Ty2&gt;
struct is_swappable_with : _Is_swappable_with&lt;_Ty1, _Ty2&gt;::type {
    // Determine if expressions with type and value category _Ty1 and _Ty2
    // can be swapped (and vice versa)
};

template &lt;class _Ty1, class _Ty2&gt;
inline constexpr bool is_swappable_with_v =
    conjunction_v&lt;_Swappable_with_helper&lt;_Ty1, _Ty2&gt;, _Swappable_with_helper&lt;_Ty2, _Ty1&gt;&gt;;

// STRUCT TEMPLATE is_swappable
template &lt;class _Ty&gt;
struct is_swappable : _Is_swappable&lt;_Ty&gt;::type {}; // Determine if _Ty lvalues satisfy is_swappable_with

template &lt;class _Ty&gt;
inline constexpr bool is_swappable_v = _Is_swappable&lt;_Ty&gt;::value;

// STRUCT TEMPLATE is_nothrow_swappable_with
template &lt;class _Ty1, class _Ty2&gt;
struct is_nothrow_swappable_with : _Is_nothrow_swappable_with&lt;_Ty1, _Ty2&gt;::type {
    // Determine if expressions with type and value category _Ty1 and _Ty2
    // satisfy is_swappable_with, and can be swapped without emitting exceptions
};

template &lt;class _Ty1, class _Ty2&gt;
inline constexpr bool is_nothrow_swappable_with_v = _Is_nothrow_swappable_with&lt;_Ty1, _Ty2&gt;::value;

// STRUCT TEMPLATE is_nothrow_swappable
template &lt;class _Ty&gt;
struct is_nothrow_swappable : _Is_nothrow_swappable&lt;_Ty&gt;::type {
    // Determine if _Ty lvalues satisfy is_nothrow_swappable_with
};

template &lt;class _Ty&gt;
inline constexpr bool is_nothrow_swappable_v = _Is_nothrow_swappable&lt;_Ty&gt;::value;
#endif // _HAS_CXX17

// TYPE TRAIT _Is_trivially_swappable
namespace _Has_ADL_swap_detail {
    void swap(); // undefined (deliberate shadowing)

    template &lt;class, class = void&gt;
    struct _Has_ADL_swap : false_type {};
    template &lt;class _Ty&gt;
    struct _Has_ADL_swap&lt;_Ty, void_t&lt;decltype(swap(_STD declval&lt;_Ty&amp;&gt;(), _STD declval&lt;_Ty&amp;&gt;()))&gt;&gt; : true_type {};
} // namespace _Has_ADL_swap_detail
using _Has_ADL_swap_detail::_Has_ADL_swap;

template &lt;class _Ty&gt;
_INLINE_VAR constexpr bool _Is_trivially_swappable_v = conjunction_v&lt;is_trivially_destructible&lt;_Ty&gt;,
    is_trivially_move_constructible&lt;_Ty&gt;, is_trivially_move_assignable&lt;_Ty&gt;, negation&lt;_Has_ADL_swap&lt;_Ty&gt;&gt;&gt;;

template &lt;class _Ty&gt;
struct _Is_trivially_swappable : bool_constant&lt;_Is_trivially_swappable_v&lt;_Ty&gt;&gt; {
    // true_type if and only if it is valid to swap two _Ty lvalues by exchanging object representations.
};

// BITMASK OPERATIONS
#define _BITMASK_OPS(_BITMASK)                                                                                      \
    _NODISCARD constexpr _BITMASK operator&amp;(_BITMASK _Left, _BITMASK _Right) noexcept { /* return _Left &amp; _Right */ \
        using _IntTy = _STD underlying_type_t&lt;_BITMASK&gt;;                                                            \
        return static_cast&lt;_BITMASK&gt;(static_cast&lt;_IntTy&gt;(_Left) &amp; static_cast&lt;_IntTy&gt;(_Right));                     \
    }                                                                                                               \
                                                                                                                    \
    _NODISCARD constexpr _BITMASK operator|(_BITMASK _Left, _BITMASK _Right) noexcept { /* return _Left | _Right */ \
        using _IntTy = _STD underlying_type_t&lt;_BITMASK&gt;;                                                            \
        return static_cast&lt;_BITMASK&gt;(static_cast&lt;_IntTy&gt;(_Left) | static_cast&lt;_IntTy&gt;(_Right));                     \
    }                                                                                                               \
                                                                                                                    \
    _NODISCARD constexpr _BITMASK operator^(_BITMASK _Left, _BITMASK _Right) noexcept { /* return _Left ^ _Right */ \
        using _IntTy = _STD underlying_type_t&lt;_BITMASK&gt;;                                                            \
        return static_cast&lt;_BITMASK&gt;(static_cast&lt;_IntTy&gt;(_Left) ^ static_cast&lt;_IntTy&gt;(_Right));                     \
    }                                                                                                               \
                                                                                                                    \
    constexpr _BITMASK&amp; operator&amp;=(_BITMASK&amp; _Left, _BITMASK _Right) noexcept { /* return _Left &amp;= _Right */        \
        return _Left = _Left &amp; _Right;                                                                              \
    }                                                                                                               \
                                                                                                                    \
    constexpr _BITMASK&amp; operator|=(_BITMASK&amp; _Left, _BITMASK _Right) noexcept { /* return _Left |= _Right */        \
        return _Left = _Left | _Right;                                                                              \
    }                                                                                                               \
                                                                                                                    \
    constexpr _BITMASK&amp; operator^=(_BITMASK&amp; _Left, _BITMASK _Right) noexcept { /* return _Left ^= _Right */        \
        return _Left = _Left ^ _Right;                                                                              \
    }                                                                                                               \
                                                                                                                    \
    _NODISCARD constexpr _BITMASK operator~(_BITMASK _Left) noexcept { /* return ~_Left */                          \
        using _IntTy = _STD underlying_type_t&lt;_BITMASK&gt;;                                                            \
        return static_cast&lt;_BITMASK&gt;(~static_cast&lt;_IntTy&gt;(_Left));                                                  \
    }                                                                                                               \
                                                                                                                    \
    _NODISCARD constexpr bool _Bitmask_includes(                                                                    \
        _BITMASK _Left, _BITMASK _Elements) noexcept { /* return (_Left &amp; _Elements) != _BITMASK{} */               \
        return (_Left &amp; _Elements) != _BITMASK{};                                                                   \
    }                                                                                                               \
                                                                                                                    \
    _NODISCARD constexpr bool _Bitmask_includes_all(                                                                \
        _BITMASK _Left, _BITMASK _Elements) noexcept { /* return (_Left &amp; _Elements) == _Elements */                \
        return (_Left &amp; _Elements) == _Elements;                                                                    \
    }

// FNV-1a UTILITIES
// These functions are extremely performance sensitive, check examples like
// that in VSO#653642 before making changes.
#if defined(_WIN64)
_INLINE_VAR constexpr size_t _FNV_offset_basis = 14695981039346656037ULL;
_INLINE_VAR constexpr size_t _FNV_prime        = 1099511628211ULL;
#else // defined(_WIN64)
_INLINE_VAR constexpr size_t _FNV_offset_basis = 2166136261U;
_INLINE_VAR constexpr size_t _FNV_prime        = 16777619U;
#endif // defined(_WIN64)

_NODISCARD inline size_t _Fnv1a_append_bytes(size_t _Val, const unsigned char* const _First,
    const size_t _Count) noexcept { // accumulate range [_First, _First + _Count) into partial FNV-1a hash _Val
    for (size_t _Idx = 0; _Idx &lt; _Count; ++_Idx) {
        _Val ^= static_cast&lt;size_t&gt;(_First[_Idx]);
        _Val *= _FNV_prime;
    }

    return _Val;
}

template &lt;class _Ty&gt;
_NODISCARD size_t _Fnv1a_append_range(const size_t _Val, const _Ty* const _First,
    const _Ty* const _Last) noexcept { // accumulate range [_First, _Last) into partial FNV-1a hash _Val
    static_assert(is_trivial_v&lt;_Ty&gt;, "Only trivial types can be directly hashed.");
    const auto _Firstb = reinterpret_cast&lt;const unsigned char*&gt;(_First);
    const auto _Lastb  = reinterpret_cast&lt;const unsigned char*&gt;(_Last);
    return _Fnv1a_append_bytes(_Val, _Firstb, static_cast&lt;size_t&gt;(_Lastb - _Firstb));
}

template &lt;class _Kty&gt;
_NODISCARD size_t _Fnv1a_append_value(
    const size_t _Val, const _Kty&amp; _Keyval) noexcept { // accumulate _Keyval into partial FNV-1a hash _Val
    static_assert(is_trivial_v&lt;_Kty&gt;, "Only trivial types can be directly hashed.");
    return _Fnv1a_append_bytes(_Val, &amp;reinterpret_cast&lt;const unsigned char&amp;&gt;(_Keyval), sizeof(_Kty));
}

// FUNCTION TEMPLATE _Hash_representation
template &lt;class _Kty&gt;
_NODISCARD size_t _Hash_representation(const _Kty&amp; _Keyval) noexcept { // bitwise hashes the representation of a key
    return _Fnv1a_append_value(_FNV_offset_basis, _Keyval);
}

// FUNCTION TEMPLATE _Hash_array_representation
template &lt;class _Kty&gt;
_NODISCARD size_t _Hash_array_representation(
    const _Kty* const _First, const size_t _Count) noexcept { // bitwise hashes the representation of an array
    static_assert(is_trivial_v&lt;_Kty&gt;, "Only trivial types can be directly hashed.");
    return _Fnv1a_append_bytes(
        _FNV_offset_basis, reinterpret_cast&lt;const unsigned char*&gt;(_First), _Count * sizeof(_Kty));
}

// STRUCT TEMPLATE _Conditionally_enabled_hash
template &lt;class _Kty&gt;
struct hash;

template &lt;class _Kty, bool _Enabled&gt;
struct _Conditionally_enabled_hash { // conditionally enabled hash base
    _CXX17_DEPRECATE_ADAPTOR_TYPEDEFS typedef _Kty argument_type;
    _CXX17_DEPRECATE_ADAPTOR_TYPEDEFS typedef size_t result_type;

    _NODISCARD size_t operator()(const _Kty&amp; _Keyval) const
        noexcept(noexcept(hash&lt;_Kty&gt;::_Do_hash(_Keyval))) /* strengthened */ {
        return hash&lt;_Kty&gt;::_Do_hash(_Keyval);
    }
};

template &lt;class _Kty&gt;
struct _Conditionally_enabled_hash&lt;_Kty, false&gt; { // conditionally disabled hash base
    _Conditionally_enabled_hash()                                   = delete;
    _Conditionally_enabled_hash(const _Conditionally_enabled_hash&amp;) = delete;
    _Conditionally_enabled_hash(_Conditionally_enabled_hash&amp;&amp;)      = delete;
    _Conditionally_enabled_hash&amp; operator=(const _Conditionally_enabled_hash&amp;) = delete;
    _Conditionally_enabled_hash&amp; operator=(_Conditionally_enabled_hash&amp;&amp;) = delete;
};

// STRUCT TEMPLATE hash
template &lt;class _Kty&gt;
struct hash
    : _Conditionally_enabled_hash&lt;_Kty,
          !is_const_v&lt;_Kty&gt; &amp;&amp; !is_volatile_v&lt;_Kty&gt; &amp;&amp; (is_enum_v&lt;_Kty&gt; || is_integral_v&lt;_Kty&gt; || is_pointer_v&lt;_Kty&gt;)&gt; {
    // hash functor primary template (handles enums, integrals, and pointers)
    static size_t _Do_hash(const _Kty&amp; _Keyval) noexcept {
        return _Hash_representation(_Keyval);
    }
};

template &lt;&gt;
struct hash&lt;float&gt; {
    _CXX17_DEPRECATE_ADAPTOR_TYPEDEFS typedef float argument_type;
    _CXX17_DEPRECATE_ADAPTOR_TYPEDEFS typedef size_t result_type;
    _NODISCARD size_t operator()(const float _Keyval) const noexcept {
        return _Hash_representation(_Keyval == 0.0F ? 0.0F : _Keyval); // map -0 to 0
    }
};

template &lt;&gt;
struct hash&lt;double&gt; {
    _CXX17_DEPRECATE_ADAPTOR_TYPEDEFS typedef double argument_type;
    _CXX17_DEPRECATE_ADAPTOR_TYPEDEFS typedef size_t result_type;
    _NODISCARD size_t operator()(const double _Keyval) const noexcept {
        return _Hash_representation(_Keyval == 0.0 ? 0.0 : _Keyval); // map -0 to 0
    }
};

template &lt;&gt;
struct hash&lt;long double&gt; {
    _CXX17_DEPRECATE_ADAPTOR_TYPEDEFS typedef long double argument_type;
    _CXX17_DEPRECATE_ADAPTOR_TYPEDEFS typedef size_t result_type;
    _NODISCARD size_t operator()(const long double _Keyval) const noexcept {
        return _Hash_representation(_Keyval == 0.0L ? 0.0L : _Keyval); // map -0 to 0
    }
};

template &lt;&gt;
struct hash&lt;nullptr_t&gt; {
    _CXX17_DEPRECATE_ADAPTOR_TYPEDEFS typedef nullptr_t argument_type;
    _CXX17_DEPRECATE_ADAPTOR_TYPEDEFS typedef size_t result_type;
    _NODISCARD size_t operator()(nullptr_t) const noexcept {
        void* _Null{};
        return _Hash_representation(_Null);
    }
};

// STRUCT TEMPLATE _Is_nothrow_hashable
template &lt;class _Kty, class = void&gt;
struct _Is_nothrow_hashable : false_type {}; // tests if std::hash can hash _Kty with noexcept

template &lt;class _Kty&gt;
struct _Is_nothrow_hashable&lt;_Kty, void_t&lt;decltype(hash&lt;_Kty&gt;{}(_STD declval&lt;const _Kty&amp;&gt;()))&gt;&gt;
    : bool_constant&lt;noexcept(hash&lt;_Kty&gt;{}(_STD declval&lt;const _Kty&amp;&gt;()))&gt; {};

#if _HAS_TR1_NAMESPACE
_STL_DISABLE_DEPRECATED_WARNING
namespace _DEPRECATE_TR1_NAMESPACE tr1 {
    using _STD add_const;
    using _STD add_cv;
    using _STD add_pointer;
    using _STD add_volatile;
    using _STD aligned_storage;
    using _STD alignment_of;
    using _STD conditional;
    using _STD decay;
    using _STD enable_if;
    using _STD extent;
    using _STD false_type;
    using _STD has_virtual_destructor;
    using _STD integral_constant;
    using _STD is_abstract;
    using _STD is_arithmetic;
    using _STD is_array;
    using _STD is_base_of;
    using _STD is_class;
    using _STD is_compound;
    using _STD is_const;
    using _STD is_convertible;
    using _STD is_empty;
    using _STD is_enum;
    using _STD is_floating_point;
    using _STD is_function;
    using _STD is_fundamental;
    using _STD is_integral;
    using _STD is_member_function_pointer;
    using _STD is_member_object_pointer;
    using _STD is_member_pointer;
    using _STD is_object;
    using _STD is_pod;
    using _STD is_pointer;
    using _STD is_polymorphic;
    using _STD is_reference;
    using _STD is_same;
    using _STD is_scalar;
    using _STD is_signed;
    using _STD is_union;
    using _STD is_unsigned;
    using _STD is_void;
    using _STD is_volatile;
    using _STD make_signed;
    using _STD make_unsigned;
    using _STD rank;
    using _STD remove_all_extents;
    using _STD remove_const;
    using _STD remove_cv;
    using _STD remove_extent;
    using _STD remove_pointer;
    using _STD remove_reference;
    using _STD remove_volatile;
    using _STD true_type;
    using _STD cref;
    using _STD ref;
    using _STD reference_wrapper;
    using _STD result_of;
    using _STD hash;
} // namespace tr1
_STL_RESTORE_DEPRECATED_WARNING
#endif // _HAS_TR1_NAMESPACE

_STD_END

#pragma pop_macro("new")
_STL_RESTORE_CLANG_WARNINGS
#pragma warning(pop)
#pragma pack(pop)
#endif // _STL_COMPILER_PREPROCESSOR
#endif // _TYPE_TRAITS_</pre>
	</body>
</html>